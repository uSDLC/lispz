window.lispz_modules={}

lispz_modules['annotations']="### spec: Annotations\n  In this context, annotations are comments in source files that can be processed\n  by an external system for processing outside normal compilation and running.\n\n  An annotation is a line containing **##<span>#</span> type: ** followed by\n  lines of text ending in ##<span>#</span>. Annotation processors use a\n  type to define which annotations they retrieve. They then receive a list of\n  objects with _title_ and _body_ elements.\n\n  Source code can be any language that supports multi-line comments:\n\n      &lt;!-- ##<span>#</span> spec: Annotations in HTML or XML\n            ...\n           ##<span>#</span> --&gt;\n      /* ##<span>#</span> spec: Annotations in a C, C++, Java, etc\n          ...\n         ##<span>#</span> */\n###\n### spec: annotations >> Processing Source Code\n  The retrieve function processes source files one at a time. It returns an\n  array of objects containing title and body members.\n\n      (describe \"(annotations.retrieve \\\"spec\\\" source-code)\" (lambda\n        (it \"retrieves a list {title: \\\"..\\\" body: \\\"..\\\"}\" (lambda\n          (using [annotations]\n            (ref source window.lispz_modules.annotations)\n            (ref list (annotations.retrieve \"spec\" source)\n            (expect list.length).toBeGreaterThan(0)\n            (ref annotation (first list))\n            (expect annotation.title).toBe(\"Annotations\")\n            (expect annotation.body.length).toBeGreaterThan(100)\n          )\n        ))\n      ))\n###\n  (ref retrieve (lambda [type source]\n    (ref re (new RegExp (+ \"###\\\\s*\" type \":\\\\s*(.*)\\\\n((?:.|\\\\n)*?)###\") \"g\"))\n    (ref annotations (stateful []))\n    (ref scan (lambda\n      (ref res (re.exec source))\n      (cond res (do\n        (annotations.push! {title: (second res)  body: (third res)})\n        (scan)\n      ))\n    ))(scan)\n    (return annotations)\n  ))\n  (export {retrieve})\n"

lispz_modules['axios']="### spec: Libraries >> Axios\nA Promise based HTTP client\n\nhttps://github.com/mzabriskie/axios\n###\n  (ref build (lambda [target-repo]\n    (using [code-builder]\n      (return (code-builder target-repo \"axios\" [[\n        {repo: \"axios/axios\" files: [[\n          {base: \"dist\" include: '/axios.js$/'}\n        ]]}\n      ]]))\n    )\n  ))\n\n  (lispz.script \"ext/axios.js\" (=> (export { build })))\n"

lispz_modules['babel']="### spec: Libraries >> Babel\nThe compiler for writing next generation JavaScript.\n\nhttps://github.com/babel/babel\n###\n(using [net cdnjs]\n  (ref build (lambda [target-repo]\n    (return (cdnjs.build target-repo \"babel\" [[\n      {repo: \"babel-standalone\" files: [[\n        {include: '/\\.min.js$/'}\n      ]]}\n    ]]))\n  ))\n  (when (net.script \"ext/jquery.js\" (=> window.Babel)) (export { build }))\n  (when-rejected (export { build }))\n)\n"

lispz_modules['base64']="### spec: Libraries >> Base64\nA robust base64 encoder/decoder that is fully compatible with `atob()` and btoa()`\n\nhttps://github.com/mathiasbynens/base64\n###\n(using  [net]\n  (ref build (lambda [target-repo] (using [code-builder]\n    (return (code-builder target-repo \"base64\" [[\n      {repo: \"mathiasbynens/base64\" files: [[\n        {base: \"\" include: '/base64.js$/'}\n      ]]}\n    ]]))\n  )))\n\n  (when (net.script \"ext/base64.js\" (=> window.base64)) (export {\n    build  encode: base64.encode  decode: base64.decode\n  }))\n)\n"

lispz_modules['bootstrap']="### spec: Bootstrap\n  The most popular HTML, CSS, and JavaScript framework for\n  developing responsive, mobile first projects on the web.\n\n  http://getbootstrap.com\n  https://github.com/twbs/bootstrap\n###\n(using [net cdnjs message list]\n  (ref bootswatch-themes [[\"cerulean\" \"cosmo\" \"cyborg\" \"darkly\" \"flatly\"\n    \"journal\" \"lumen\" \"paper\" \"readable\" \"sandstone\" \"simplex\" \"slate\"\n    \"spacelab\" \"superhero\" \"united\" \"yeti\" \"default\"]])\n\n  (ref build (lambda [target-repo]\n    (return (promise.all\n      (code-builder target-repo \"bootstrap\" [[\n        {repo: \"twbs/bootstrap\" files: [[\n          {base: \"dist\" exclude: '/\\.map$|\\.min\\.|npm.js$/'}\n          {base: \"dist/fonts\" copy-to: \"fonts\"}\n        ]]}\n      ]])\n      (bootswatch-themes.map (lambda [theme]\n        (return (cdnjs.build target-repo (+ \"bootstrap-\" theme) [[\n          {repo: \"bootswatch\" files: [[{include: (+ theme \"/bootstrap.css\")}]]}\n        ]]))\n      ))\n    ))\n  ))\n\n  (lispz.css \"ext/bootstrap.css\")\n  (ref themes bootswatch-themes)\n  (ref random-theme (dot (random themes.length) in bootswatch-themes))\n\n  ### spec: Bootstrap >> Bootswatch\n  # https://bootswatch.com\n  # Loads a bootswatch theme to make the page look different.\n  # If no theme is provided, a random one is selected.\n  ###\n  (message.listen \"bootstrap/change-theme\" (lambda [theme-name]\n    (ref theme\n      (cond (not (defined? theme-name)) (random-theme)\n            (else)                      theme-name\n      )\n    )\n    (net.css (+ \"ext/bootstrap-\" theme \".css\"))\n  ))\n  ### spec: Bootstrap >> modal\n    Open a named modal dialog box and wait for a user response. Options:\n\n    * seed - object to fill modal form fields\n    * attributes - for the element being created\n  ###\n  (ref modal> (promise [name-path opts] (using [riot dom]\n    (ref name (last (name-path.split \"/\")))\n    (ref address (+ \"modal/\" name))\n    (ref show-modal (=> (message.send (+ address \"/show\"))))\n    (cond (get lispz.tags name) (show-modal)\n    (else) ## modals are singletons, load once\n      (when (riot.inject name-path opts.attributes)\n        (show-modal)\n      )\n    )\n    (ref hidden-address (+ address \"/hidden\"))\n    (message.listen hidden-address (=>\n      (message.clear hidden-address)\n      (resolve-promise (dom.scrape-form @.element))\n    ))\n  )))\n  ### ref: (bootstrap.path-to-tree path-list) ## ready for tree or menu\n    item is { divider: true disabled: true title header children: {} }\n    e.g. (bootstrap.path-to-tree [\"a/b\" \"a/c\" \"d/e\" \"f\"])\n  ###\n  (ref path-to-tree (lambda [path-list]\n    (ref paths ((list.sort path-list).map (=> (@.split \"/\"))))\n    (ref tree (stateful))\n    (list.for-each paths (lambda [path]\n      (ref level (lambda [branches]\n        (cond (> branches.length 1) (do\n          ## we are at a branch, recursive call to add more\n          (ref title 	 (first branches))\n          (ref sub-branch (level (rest branches)))\n          (ref children  (stateful))\n          (children.update! (second branches) sub-branch)\n          { title children }\n        )(else) ## at leaf - time to retrace the recursion\n          { title: (first branches) }\n        )\n      ))\n      (tree.update! (first path) (level path))\n    ))\n    tree\n  ))\n\n  ### spec: Bootstrap >> loading\n    We know that bootstrap has completed loading\n    when we see _modal_ added to the list of\n    JQuery functions.\n  ###\n  (when (net.script \"ext/bootstrap.js\" (=> (($).modal)))\n    (export { build themes modal> path-to-tree })\n  )\n  (when-rejected (export { build }))\n)\n"

lispz_modules['cdnjs']="### Load packages from CDN and other web sources - listing them when possible ###\n(using [net github list]\n  (ref cdnjs-actors {\n    list-all: (promise [repo path]\n      (ref base \"http://api.cdnjs.com/libraries?fields=assets&search=\")\n      (when (net.json-request (+ base repo.name)) [json]\n        ## select the correct repo for the name\n        (ref filtered (json.results.filter (lambda [it]\n          (return (=== it.name repo.name))\n        )))\n        (cond (filtered.length)\n          ((first filtered).assets.some (lambda [it]\n            (cond\n              (list.contains \"alpha\" it.version) false\n              (else) (do\n                (repo.update! {base: (+\n                  \"https://cdnjs.cloudflare.com/ajax/libs/\"\n                  repo.name \"/\" it.version \"/\"\n                )})\n                (resolve-promise it.files)\n                true ## found the one we want\n              ))\n          ))\n        (else)\n          false\n        )\n      )\n    )\n    read: (promise [repo path]\n      (ref uri (+ repo.base path))\n      (when (net.http-get uri) [response] (resolve-promise response))\n    )\n    repo: (lambda [target-repo name] (return (stateful {})))\n  })\n\n  (export {\n  })\n)\n"

lispz_modules['chain']="### spec: functions >> chaining -- Chaining functions\n  In a functional style we often call multiple functions to incrementally move\n  from problem to solution. Each step takes the results from the step before and\n  transforms it. It is allways a good idea to have short functions that do one\n  thing - for testing, maintenance and readability. Speaking of readability,\n  chain makes the sequence of events clear.\n\n      (parse-titles (lambda [sections] (return (sections.map ...)))\n      (sort-titles  (lambda [sections] (return (sections.map ...)))\n      (merge-titles (lambda [sections] (return (sections.map ...)))\n\n      ((chain parse-titles sort-titles merge-titles) sections)\n###\n### spec: chain\n  (describe \"chain: run each function with the results from the one before\" (llbda []\n    (it \"(chain f1 f2 ...)\" (lambda []\n      (ref f1 (lambda [a] (return 2)))\n      (ref f2 (lambda [a] (return (+ a 3))))\n      (ref f3 (lambda [a] (return (* a 10))))\n      ((expect (chain f1 f2 f3)).toBe 50)\n    ))\n  ))\n###\n(export (lambda [] (ref functions (*arguments))\n  (ref link (lambda [arg func] (return (func arg))))\n  (return (lambdas.reduce link null))\n))\n"

lispz_modules['code-builder']="(using  [github compilers]\n  ###\n    Code-builder needs to be provided source and destination file-system\n    objects that contain:\n\n    # (ref fs = (github.fs name [branch]))\n    # (fs.list>)\n    # (fs.read> path)\n    # (fs.write> path contents comment)\n\n    Sources are defined as an array of entries with:\n\n    # system: file-system (default github)\n    # repo:   fully qualified (e.g. \"paulmarrington/lispz\")\n    # branch: branch or has to qualify repo requests (default \"master\")\n    # files:  array of file filters\n    ## base:  base path to the file(s)\n    ## include: regular expression of files to include; or\n    ## exclude: regular expression of files to exclude\n  ###\n\n  ## Compile down to js, css or html\n  (ref preprocess> (lambda [path code]\n    (ref ext (last (path.split \".\")))\n    (ref preprocessor  (get compilers ext))\n    (cond preprocessor\n      (when (preprocessor.compile code path) [code] { path ext code })\n    (else)\n      { path ext code }\n    )\n  ))\n\n  ## Build and save a dependency list\n  ## We will need to filter the dependencies\n  (ref filter (lambda [before include exclude]\n    (cond\n      include (before.filter (lambda [file] (include.test file)))\n      exclude (before.filter (lambda [file] (not (exclude.test file))))\n    )\n  ))\n\n  ## and see which to save and which to copy\n  (ref copy (lambda [copy-to path code]\n    ## not working yet for binary files\n    (ref filename (last (path.split \"/\")))\n    (return {path code copy: (+ copy-to \"/\" filename)})\n  ))\n\n  (ref read-file> (lambda [file repo]\n    (when (repo.list>) [file-tree]\n    (when (repo.read> path) [code]\n      (ref meta (get file-tree path))\n      (cond\n        meta.copy-to (copy meta.copy-to path code)\n        (else)       (preprocess> path code)\n      )\n    ))\n  ))\n\n  (ref process-entry> (lambda [entry repo]\n    (ref base (or entry.base \"\"))\n    (when (repo.list>) [file-tree]\n      (ref files (dict.map file-tree.map (=> @)))\n      (ref filtered (filter file-list entry.include entry.exclude))\n      (promise.all (filtered.map (=> (read-file> @ repo))))\n    )\n  ))\n\n  (ref process-repo> (lambda [repo files]\n    (promise.all (files.map (=> (process-entry> @ repo))))\n  ))\n\n  (ref process-repos> (lambda [sources]\n    (promise.all (sources.map (lambda [source]\n      (ref fs (or source.system github).fs)\n      (ref repo (fs source.repo source.branch))\n      (return (process-repo> repo source.files))\n    )))\n  ))\n  ## Retrieve file contents based of filtering meta-data\n  (ref retriever> (lambda [sources]\n    (when (process-repos sources) [entry-tree]\n      (ref entries  (list.flatten entry-tree))\n      (ref filter   (lambda [ext] (entries.filter (=> (= @.ext ext)))))\n      (ref for-unknown (=> (not (list.contains(@ [[\"js\" \"css\"]])))))\n      (ref format   (=> \"\\n\\n/* \" @.path \" */\\n\" @.code))\n      (ref from     [[\"Gathered from: \"]])\n      {\n        js:     ((filter  \"js\").map format)\n        css:    ((filter \"css\").map format)\n        copies: (entries.filter for-unknown)\n        from:   (from.concat sources.map(=> @.repo))\n      }\n    )\n  ))\n\n  ## Given a file type, save the concatenated source contents\n  (ref save-store (promise [target store ext comment]\n    (ref contents ((get store ext).join \"\"))\n    (target.repo.write> (+ \"ext/\" target.name \".\" ext) contents comment)\n  ))\n\n  ## copy files identified as needed as-is\n  (ref copy-store (lambda [target store comment]\n    (promise.all (store.copies.map (lambda [entry]\n      (target.repo.write> entry.path entry.code comment)\n    )))\n  ))\n\n  ### ref: (code-builder repo name)\n    e.g. (code-builder {\n      repo: (github.fs \"paulmarrington/lispz\" \"master\")})\n  ###\n  (ref builder (lambda [target-repo name sources]\n    (when (retriever sources) [store]\n      (ref target { repo: target-repo  name })\n      (ref comment (store.from.join \" \"))\n      (promise.all\n        (save-store target store \"js\"  comment)\n        (save-store target store \"css\" comment)\n        (copy-store target store       comment)\n      )\n    )\n  ))\n\n  (export builder)\n)\n"

lispz_modules['codemirror']="### spec: Libraries >> CodeMirror\nIn-browser code editor http://codemirror.net/\n\nhttps://github.com/codemirror/CodeMirror\n###\n(using  [net diff_match_patch message message dict compilers]\n  (ref options-string (localStorage.getItem \"CodeMirror-options\"))\n  (ref options (stateful.morph!\n    (cond options-string (JSON.parse options-string)\n    (else)  {\n      lineNumbers:        true\n      foldGutter:         true\n  ##  gutters:            [\"CodeMirror-lint-markers\"\n  ##                       \"CodeMirror-foldgutter\"]\n      lint:               true\n      matchBrackets:      true\n      autoCloseBrackets:  true\n      matchTags:          true\n      showTrailingSpace:  true\n      inputStyle:         \"textarea\" ## change to \"contenteditable\" after vim cursor bug fix\n      autofocus:          false\n      dragDrop:           false\n      smartIndent:        true\n      indentUnit:         2\n      indentWithTabs:     false\n      cursorScrollMargin: 5\n      scrollbarStyle:     \"overlay\"\n      extraKeys:          {\n        'Cmd-Left':         \"goLineStartSmart\"\n        'Ctrl-Q':           \"fold_at_cursor\"\n        'Ctrl-Space':       \"autocomplete\"\n        'Ctrl-/':           \"toggleComment\"\n        'Ctrl-<':           \"goColumnLeft\"\n        'Ctrl->':           \"goColumnRight\"\n        'Ctrl-Shift-F':     \"clearSearch\"\n        'Ctrl-=':           \"toMatchingTag\"\n        'Alt-S':            \"view_source\"\n        'Ctrl-`':           \"insertSoftTab\"\n        'Ctrl-,':           \"delLineLeft\"\n        'Ctrl-.':           \"killLine\"\n        'Shift-Ctrl-,':     \"delWrappedLineLeft\"\n        'Shift-Ctrl-.':     \"delWrappedLineRight\"\n        'Ctrl-9':           \"delWordBefore\"\n        'Ctrl-0':           \"delWordAfter\"\n        'Ctrl-6':           \"transposeChars\"\n        'Ctrl-Left':        \"goWordLeft\"\n        'Ctrl-Right':       \"goWordRight\"\n        'Ctrl-Home':        \"goLineLeft\"\n        'Ctrl-Shift-Home':  \"goLineLeftSmart\"\n        'Ctrl-End':         \"goLineRight\"\n        ## paredit keys that defer if not in lisp code\n        'Backspace':        \"subpar_backward_delete\"\n        'Delete':           \"subpar_forward_delete\"\n        'Ctrl-D':           \"subpar_forward_delete\"\n\n        'Shift-9':          \"subpar_open_bracket\"\n        '[':                \"subpar_open_square_bracket\"\n        'Shift-[':          \"subpar_open_braces\"\n\n        'Shift-0':          \"subpar_close_bracket\"\n        ']':                \"subpar_close_square_bracket\"\n        'Shift-]':          \"subpar_close_braces\"\n\n        'Shift-\\'':          \"subpar_double_quote\"\n\n        'Ctrl-Alt-F':       \"subpar_forward\"\n        'Ctrl-Alt-B':       \"subpar_backward\"\n        'Ctrl-Alt-U':       \"subpar_backward_up\"\n        'Ctrl-Alt-D':       \"subpar_forward_down\"\n        'Ctrl-Alt-P':       \"subpar_backward_down\"\n        'Ctrl-Alt-N':       \"subpar_forward_up\"\n\n        'Shift-Ctrl-[':     \"subpar_backward_barf\"\n        'Ctrl-Alt-Right':   \"subpar_backward_barf\"\n        'Ctrl-]':           \"subpar_backward_barf\"\n\n        'Shift-Ctrl-]':     \"subpar_forward_barf\"\n        'Ctrl-Left':        \"subpar_forward_barf\"\n\n        'Shift-Ctrl-9':     \"subpar_backward_slurp\"\n        'Ctrl-Alt-Left':    \"subpar_backward_slurp\"\n        'Ctrl-[':           \"subpar_backward_slurp\"\n\n        'Shift-Ctrl-0':     \"subpar_forward_slurp\"\n        'Ctrl-Right':       \"subpar_forward_slurp\"\n\n        'Alt-Up':           \"subpar_splice_delete_backward\"\n        'Alt-Down':         \"subpar_splice_delete_forward\"\n        'Alt-S':            \"subpar_splice\"\n        'Ctrl-Alt-/':       \"subpar_indent_selection\"\n\n        'Alt-Enter':        \"run_selection\"\n       }\n    })\n  ))\n  ## write changed options back to persistent storage\n  (ref update-options (lambda\n    (localStorage.setItem \"CodeMirror-options\" (JSON.stringify options))\n  ))\n  ## Context menu for code editor\n  (ref topic \"codemirror/command\")\n  (ref menu [[\n    ### {title: \"File\" children: [[\n      {topic meta: \"save\" title: \"Save\"}\n    ]]} ###\n    {title: \"Edit\" children: [[\n      {topic meta: \"autocomplete\" title: \"Auto-Complete\" }\n      {topic meta: \"redo\" title: \"Redo\"}\n      {topic meta: \"undo\" title: \"Undo\"}\n      {topic meta: \"redoSelection\" title: \"Redo Selection\"}\n      {topic meta: \"undoSelection\" title: \"Undo Selection\"}\n      {divider: true}\n      {topic meta: \"toggleOverwrite\" title: \"Insert/Overwrite\"}\n      {topic meta: \"toggleComment\" title: \"Comment/Uncomment\" }\n      {topic meta: \"insertSoftTab\" title: \"Insert Soft Tab\" }\n      {topic meta: \"defaultTab\" title: \"Tab or Indent\"}\n      {title: \"Delete\" children: [[\n        {topic meta: \"deleteLine\" title: \"Line\"}\n        {topic meta: \"killLine\" title: \"Line Right\" }\n        {topic meta: \"delLineLeft\" title: \"Line Left\" }\n        {divider: true}\n        {topic meta: \"delWrappedLineLeft\" title: \"Wrapped Line Left\" }\n        {topic meta: \"delWrappedLineRight\" title: \"Wrapped Line Right\" }\n        {divider: true}\n        {topic meta: \"delWordBefore\" title: \"Word Left\" }\n        {topic meta: \"delWordAfter\" title: \"Word Right\" }\n        {divider: true}\n        {topic meta: \"delGroupBefore\" title: \"Group Before\"}\n        {topic meta: \"delGroupAfter\" title: \"Group After\"}\n        {divider: true}\n        {topic meta: \"delCharBefore\" title: \"Character Left\"}\n        {topic meta: \"delCharAfter\" title: \"Character Right\"}\n      ]]}\n      {topic meta: \"indentAuto\" title: \"Auto Indent\"}\n      {topic meta: \"indentLess\" title: \"Indent Left\"}\n      {topic meta: \"indentMore\" title: \"Indent Right\"}\n      {topic meta: \"newlineAndIndent\" title: \"New line and indent\"}\n      {divider: true}\n      {topic meta: \"transposeChars\" title: \"Transpose Characters\" }\n      {divider: true}\n      {topic meta: \"selectAll\" title: \"Select All\"}\n      {topic meta: \"singleSelection\" title: \"Single Selection\"}\n    ]]}\n    {title: \"Go\" children: [[\n      {topic meta: \"goDocStart\" title: \"Document Start\"}\n      {topic meta: \"goDocEnd\" title: \"Document End\"}\n      {divider: true}\n      {topic meta: \"goCharLeft\" title: \"Char Left\"}\n      {topic meta: \"goCharRight\" title: \"Char Right\"}\n      {divider: true}\n      {topic meta: \"goColumnLeft\" title: \"Column Left\" }\n      {topic meta: \"goColumnRight\" title: \"Column Right\" }\n      {divider: true}\n      {topic meta: \"goGroupLeft\" title: \"Group Left\"}\n      {topic meta: \"goGroupRight\" title: \"Group Right\"}\n      {divider: true}\n      {topic meta: \"goWordLeft\" title: \"Word Left\" }\n      {topic meta: \"goWordRight\" title: \"Word Right\" }\n      {divider: true}\n      {topic meta: \"goLineStart\" title: \"Line Start\"}\n      {topic meta: \"goLineStartSmart\" title: \"Smart Line Start\" }\n      {topic meta: \"goLineEnd\" title: \"Line End\"}\n      {divider: true}\n      {topic meta: \"goLineLeft\" title: \"Line Left\" }\n      {topic meta: \"goLineLeftSmart\" title: \"Smart Line Left\" }\n      {topic meta: \"goLineRight\" title: \"Line Right\" }\n      {divider: true}\n      {topic meta: \"goLineUp\" title: \"Line Up\"}\n      {topic meta: \"goLineDown\" title: \"Line Down\"}\n      {divider: true}\n      {topic meta: \"goPageUp\" title: \"Page Up\"}\n      {topic meta: \"goPageDown\" title: \"Page Down\"}\n    ]]}\n    {title: \"Search\" children: [[\n      {topic meta: \"find\" title: \"Find...\"}\n      {topic meta: \"findNext\" title: \"Find Next\"}\n      {topic meta: \"findPrev\" title: \"Find Previous\"}\n      {topic meta: \"clearSearch\" title: \"Clear Search\" }\n      {divider: true}\n      {topic meta: \"replace\" title: \"Replace\"}\n      {topic meta: \"replaceAll\" title: \"Replace All\"}\n      ## {divider: true} appears to only work for XML\n      ## {topic meta: \"toMatchingTag\" title: \"Matching Tag\" }\n    ]]}\n    {title: \"View\" children: [[\n      {topic meta: \"view_keyboard_shortcuts\" title: \"Keyboard Shortcuts\" }\n      {topic meta: \"fold_at_cursor\" title: \"Fold at Cursor\" }\n      {title: \"Theme\" children: [[\n        {title: \"Dark\" children: [[\n          {topic meta: \"set_option,theme,3024-night\" title: \"3024\"}\n          {topic meta: \"set_option,theme,ambiance\" title: \"Ambience\"}\n          {topic meta: \"set_option,theme,ambiance-mobile\" title: \"Ambience (mobile)\"}\n          {topic meta: \"set_option,theme,base16-dark\" title: \"Base 16\"}\n          {topic meta: \"set_option,theme,blackboard\" title: \"Blackboard\"}\n          {topic meta: \"set_option,theme,cobalt\" title: \"Cobalt\"}\n          {topic meta: \"set_option,theme,colorforth\" title: \"Colour Forth\"}\n          {topic meta: \"set_option,theme,erlang-dark\" title: \"Erlang Dark\"}\n          {topic meta: \"set_option,theme,lesser-dark\" title: \"Lesser Dark\"}\n          {topic meta: \"set_option,theme,mbo\" title: \"MBO\"}\n          {topic meta: \"set_option,theme,midnight\" title: \"Midnight\"}\n          {topic meta: \"set_option,theme,monokai\" title: \"Monokai\"}\n          {topic meta: \"set_option,theme,night\" title: \"Night\"}\n          {topic meta: \"set_option,theme,paraiso-dark\" title: \"Paraiso\"}\n          {topic meta: \"set_option,theme,pastel-on-dark\" title: \"Pastel\"}\n          {topic meta: \"set_option,theme,rubyblue\" title: \"Ruby Blue\"}\n          {topic meta: \"set_option,theme,the-matrix\" title: \"The Matrix\"}\n          {topic meta: \"set_option,theme,tomorrow-night-bright\" title: \"Tomorrow Night\"}\n          {topic meta: \"set_option,theme,tomorrow-night-eighties\" title: \"Tomorrow Night Eighties\"}\n          {topic meta: \"set_option,theme,twilight\" title: \"Twilight\"}\n          {topic meta: \"set_option,theme,vibrant-ink\" title: \"Vibrant Ink\"}\n          {topic meta: \"set_option,theme,xq-dark\" title: \"XQ Dark\"}\n          {topic meta: \"set_option,theme,zenburn\" title: \"Zenburn\"}\n        ]]}\n        {title: \"Light\" children: [[\n          {topic meta: \"set_option,theme,3024-day\" title: \"3024\"}\n          {topic meta: \"set_option,theme,base16-light\" title: \"Base 16\"}\n          {topic meta: \"set_option,theme,default\" title: \"Default\"}\n          {topic meta: \"set_option,theme,eclipse\" title: \"Eclipse\"}\n          {topic meta: \"set_option,theme,elegant\" title: \"Elegant\"}\n          {topic meta: \"set_option,theme,mdn-line\" title: \"MDN\"}\n          {topic meta: \"set_option,theme,neat\" title: \"Neat\"}\n          {topic meta: \"set_option,theme,neo>Neo\"}\n          {topic meta: \"set_option,theme,paraiso-light\" title: \"Paraiso\"}\n          {topic meta: \"set_option,theme,solarized\" title: \"Solarized\"}\n          {topic meta: \"set_option,theme,xq-light\" title: \"XQ Light\"}\n        ]]}\n      ]]}\n    ]]}\n    {title: \"Settings\" children: [[\n      {title: \"Keyboard\" children: [[\n        {topic meta: \"set_mode,default\" title: \"Code Mirror\"}\n        {topic meta: \"set_mode,emacs\" title: \"Emacs\"}\n        {topic meta: \"set_mode,sublime\" title: \"Sublime\"}\n        {topic meta: \"set_mode,vim\" title: \"Vi\"}\n      ]]}\n      {divider: true}\n      {topic meta: \"toggle_option,smartIndent\" title: \"Auto-indent\"}\n      {title: \"Indent\" children: [[\n        {topic meta: \"set_option,indentUnit,2\" title: \"2\"}\n        {topic meta: \"set_option,indentUnit,4\" title: \"4\"}\n      ]]}\n      {topic meta: \"toggle_option,autoCloseBrackets\" title: \"Close Brackets\"}\n      {topic meta: \"toggle_option,matchBrackets\" title: \"Match Brackets\"}\n      {topic meta: \"toggle_option,matchTags\" title: \"Match Tags\"}\n      {divider: true}\n      {title: \"Scroll Margin\" children: [[\n        {topic meta: \"set_option,cursorScrollMargin,0\" title: \"0\"}\n        {topic meta: \"set_option,cursorScrollMargin,2\" title: \"2\"}\n        {topic meta: \"set_option,cursorScrollMargin,4\" title: \"4\"}\n      ]]}\n      {topic meta: \"toggle_option,continueComments\" title: \"Comment Continuation\"}\n      {topic meta: \"toggle_option,showTrailingSpace\" title: \"Show Trailing Spaces\"}\n      {topic meta: \"toggle_option,dragDrop\" title: \"Toggle Drag and Drop\"}\n      {topic meta: \"toggle_option,lineNumbers\" title: \"Toggle Line Numbers\"}\n      {topic meta: \"toggle_option,lineWrapping\" title: \"Toggle Line Wrap\"}\n    ]]}\n  ]])\n  (ref listener (lambda [cm data]\n    (ref args (data.item.meta.split \",\"))\n    (ref command (args.shift))\n    (args.unshift cm)\n    ((get CodeMirror command).apply CodeMirror args)\n  ))\n  (ref open (lambda [owner wrapper]\n    (ref cm (stateful.morph! (CodeMirror wrapper options)))\n    (cm.update! {listener-address: (+ owner \"/\" topic)})\n    (message.send \"codemirror/menu\" menu)\n    (message.listen cm.listener-address (lambda [data] (listener cm data)))\n    (return cm)\n  ))\n  (ref close (lambda [cm]\n    (message.clear cm.listener-address)\n  ))\n  (ref spaces \"                \")\n\n  (ref extra-commands {\n    view_keyboard_shortcuts: (lambda [cm]\n      (ref keys (stateful []))\n      (ref one-map (lambda [key-map]\n        ((Object.keys key-map).forEach (lambda [key]\n          (ref key-value (get key-map key))\n          (cond\n            (is key \"fallthrough\") (do\n                (ref more (cond\n                  (is (typeof key-value) \"string\") [[key-value]]\n                  (else)                           key-value\n                ))\n                (more.forEach (lambda [key-map]\n                  (one-map (get CodeMirror.keyMap key-map))\n                ))\n              )\n            (else) (keys.push! (+ key \": \" key-value))\n          )\n        ))\n      ))\n      (one-map cm.options.extraKeys)\n      (ref core (stateful.morph! (get CodeMirror.keyMap key-map cm.options.keyMap)))\n      (cond (not core.fallthrough)\n        (core.update! {fallthrough: CodeMirror.keyMap.default.fallthrough}))\n      (one-map core)\n      (window.open\n        (+ \"data:text/html,\" (encodeURIComponent (keys.join \"<br>\")))\n        \"Keys\" \"width=300,height=600\")\n    )\n    fold_at_cursor: (lambda [cm]\n      (cm.foldCode (cm.getCursor))\n    )\n    toggle_option: (lambda [cm name]\n      (CodeMirror.commands.set_option cm name (not (cm.getOption name)))\n    )\n    set_option: (lambda [cm name value]\n      (cm.setOption name value)\n      (options.update! name value)\n      (update-options)\n    )\n    set_mode: (lambda [cm mode]\n      (CodeMirror.commands.set_option cm \"keyMap\" mode)\n    )\n    auto_complete: (lambda [cm]\n      (ref not-only (lambda\n        (ref result (CodeMirror.hint.anyword arguments))\n        (cond\n          (isnt result.list.length 1) result\n          (else) (do\n            (ref size (- result.to.ch result.from.ch))\n            (ref first-choice (first result.list))\n            (cond\n              (isnt first-choice.length size) result\n              (else) ((stateful.morph! result) {list: [[]]}))\n        ))\n      ))\n    )\n  })\n  ## Editing modes dependent on file type\n  (ref default-mode-extensions {\n    apl: \"apl\" as3: \"apl\" asf: \"apl\"\n    c: \"clike\" cpp: \"clike\" h: \"clike\" cs: \"clike\"\n    chh: \"clike\" hh: \"clike\" h__: \"clike\" hpp: \"clike\"\n    hxx: \"clike\" cc: \"clike\" cxx: \"clike\" c__: \"clike\"\n    \"c++\": \"clike\" stl: \"clike\" sma: \"clike\"\n    java: \"clike\" scala: \"clike\" clj: \"clojure\"\n    cpy: \"cobol\" cbl: \"cobol\"cob: \"cobol\"\n    coffee: \"coffeescript\" coffeescript: \"coffeescript\"\n    \"gwt.coffee\": \"coffeescript\"\n    vlx: \"commonlisp\" fas: \"commonlisp\" lsp: \"commonlisp\"\n    el: \"commonlisp\" css: \"css\" less: \"css\"\n    dl: \"d\" d: \"d\" diff: \"diff\" dtd: \"dtd\" dylan: \"dylan\"\n    ecl: \"ecl\" e: \"eiffel\" erl: \"erlang\" hrl: \"erlang\"\n    f: \"fortran\" for: \"fortran\" FOR: \"fortran\"\n    f95: \"fortran\" f90: \"fortran\" f03: \"fortran\"\n    gas: \"gas\" gfm: \"gfm\" feature: \"gherkin\" go: \"go\"\n    groovy: \"groovy\" \"html.haml\": \"haml\" hx: \"haxe\"\n    lhs: \"haskell\" gs: \"haskell\" hs: \"haskell\"\n    asp: \"htmlembedded\" jsp: \"htmlembedded\"\n    ejs: \"htmlembedded\" http: \"http\"\n    html: \"htmlmixed\" htm: \"htmlmixed\" \".py.jade\": \"jade\"\n    js: \"javascript\" json: \"javascript\" jinja2: \"jinja2\"\n    jl: \"julia\" ls: \"livescript\" lua: \"lua\"\n    markdown: \"markdown\" mdown: \"markdown\" mkdn: \"markdown\"\n    md: \"markdown\" mkd: \"markdown\" mdwn: \"markdown\"\n    mdtxt: \"markdown\" mdtext: \"markdown\"\n    mdx: \"mirc\" dcx: \"mirc\"\n    ml: \"mllike\" fs: \"mllike\" fsi: \"mllike\"\n    mli: \"mllike\" fsx: \"mllike\" fsscript: \"mllike\"\n    nginx: \"nginx\" nt: \"ntriples\" mex: \"octave\"\n    pas: \"pascal\" pegjs: \"pegjs\" ps: \"perl\"\n    php: \"php\" \"lib.php\": \"php\"\n    pig: \"pig\" ini: \"properties\" properties: \"properties\"\n    pp: \"puppet\" py: \"python\" q: \"q\" r: \"r\"\n    rpm: \"rpm\" \"src.rpm\": \"rpm\" rst: \"rst\" rb: \"ruby\"\n    rs: \"rust\" sass: \"sass\" scm: \"scheme\" ss: \"scheme\"\n    sh: \"shell\" sieve: \"sieve\"\n    sm: \"smalltalk\" st: \"smalltalk\" tpl: \"smartymixed\"\n    solr: \"solr\" sparql: \"sparql\" sql: \"sql\"\n    stex: \"stex\" tex: \"stex\" tcl: \"tcl\" tw: \"tiddlywiki\"\n    tiki: \"tiki\" toml: \"toml\" ttl: \"turtle\" vb: \"vb\"\n    bas: \"vbscript\" vbs: \"vbscript\" vtl: \"velocity\"\n    v: \"verilog\" xml: \"xml\"\n    xquery: \"xquery\" xq: \"xquery\" xqy: \"xquery\"\n    yaml: \"yaml\" yml: \"yaml\" z80: \"z80\" asm: \"z80\"\n  })\n  (ref saved-mode-extensions localStorage.CodeMirror-mode-extensions)\n  (ref mode-extensions (cond\n    saved-mode-extensions\n      (dict.merge default-mode-extensions (JSON.parse saved-mode-extensions))\n    (else)\n      default-mode-extensions\n  ))\n  (ref get-mode-extension (pull mode-extensions))\n\n  (ref set-mode (lambda [cm name]\n    (ref mode (do\n      (ref parts (name.split \".\"))\n      (ref exts (parts.slice (cond (> parts.length 2) -2 (else) -1)))\n      (ref ext (exts.join \".\"))\n      (ref mode-extension (get mode-extensions ext))\n      (cond mode-extension             mode-extension\n            (get CodeMirror.modes ext) ext\n            (else)                     \"text\"\n      )\n    ))\n    (cm.setOption \"mode\" mode)\n    (CodeMirror.autoLoadMode cm mode)\n  ))\n\n  ## CodeMirror lispz mode\n  (ref init-lispz-mode (lambda\n  (CodeMirror.defineSimpleMode \"lispz\" {\n    start: [[\n      {regex: '/\"\"/'                                 token: \"string\"}\n      {regex: '/\"/'                   next: \"string\" token: \"string\"}\n      {regex: '/\\'(?:[^\\\\]|\\\\.)*?\\'/'                token: \"variable-2\"}\n      {regex: '/###/'                next: \"comment\" token: \"comment\" }\n      {regex: '/(\\()(?:([^\\s\\(\\[\\{\\)\\}\\]]*?(?:!|\\.push!?|\\.pop!?\\b))|(stateful\\b))/'\n                                indent: true  token: [[\"bracket\" \"error\" \"error\"]]}\n      {regex: '/(\\()([^\\s\\(\\[\\{\\)\\}\\]]+)/'\n                                indent: true  token: [[\"bracket\" \"keyword\"]]}\n      {regex: '/true|false|null|undefined|debugger/' token: \"atom\"}\n      {regex: '/0x[a-f\\d]+|[-+]?(?:\\.\\d+|\\d+\\.?\\d*)(?:e[-+]?\\d+)?/i'\n                                                     token: \"number\"}\n      {regex: '/## .*/'                              token: \"comment\"}\n      {regex: '/[\\{\\(\\[]/'        indent: true       token: \"bracket\"}\n      {regex: '/[\\}\\)\\]]/'        dedent: true       token: \"bracket\"}\n      {regex: '/[^\\s\\(\\{\\[\\)\\]\\}]+/'                 token: \"variable\"}\n      {regex: '/\\s+/' next: \"start\"}\n    ]]\n    comment: [[\n      {regex: '/###/' token: \"comment\" next: \"start\"}\n      {regex: '/.*/'  token: \"comment\"}\n    ]]\n    string: [[\n      {regex: '/[^\\\\]\"/' token: \"string\" next: \"start\"}\n      {regex: '/./' token: \"string\"}\n    ]]\n    meta: { lineComment: \"## \" dontIndentStates: [[\"comment\" \"string\"]] }\n  })\n  (CodeMirror.defineMIME \"text/lispz\" \"lispz\")\n  ## Update htmlmixed to understand lispz scripts\n  (ref mimeModes (stateful.morph! CodeMirror.mimeModes))\n  (cond (is (typeof (get mimeModes \"text/html\")) \"string\")\n        (mimeModes.update! \"text/html\" {name: \"htmlmixed\"}))\n  (ref mode (stateful.morph! (get mimeModes \"text/html\")))\n  (cond (not mode.scriptTypes) (mode.update! {scriptTypes: [[]]}))\n  (ref scriptTypes (stateful mode.scriptTypes))\n  (scriptTypes.push! {matches: '/^text\\/lispz$/' mode: \"lispz\"})\n  (mimeModes.update! {htmlmixed: mode})\n\n  (ref get-source (=> (cond\n    (@.somethingSelected)  (@.doc.getSelection)\n    (else)                 (@.doc.getValue)\n  )))\n\n  (ref get-compiler (=>\n    (ref mode     (@.getModeAt (@.getCursor)))\n    (ref compiler (get compilers mode.name))\n    (cond\n      compiler compiler\n      (else)   { compile: (=> \"\") }\n    )\n  ))\n\n  (ref compile (lambda [cm name]\n    ((get-compiler cm).compile (get-source cm))\n  ))\n\n  (ref run_selection (lambda [cm]\n    (ref compiler (get-compiler cm))\n    (ref source (get-source cm))\n\n    (message.send \"code-editor/run/prepare\" { source })\n    (ref js (compiler.compile source ))\n    (message.send \"code-editor/run/compiled\" { source js })\n    (compilers.run js)\n  ))\n  ### spec: codemirror >> Compiling Code\n    To send the compiler output to anywhere but the console, use a copy of the\n    following code.\n      (message.send \"code-editor/compile/js\" (lambda [compiled]\n        ## compiled: {name source js}\n      ))\n  ###\n  (message.listen \"code-editor/compile/js\" (lambda [compiled]))\n  ### spec:\n    To process the console output from running compiled code:\n      (message.listen \"code-editor/run/output\" (lambda [run]\n        ## run: {name source output}\n      ))\n  ###\n  (message.listen \"code-editor/run/output\" (lambda [run]\n    ## (console.log run.output)\n  ))\n\n  (ref lisp-modes {lispz: true clojure: true commonlisp: true scheme: true})\n  (ref lisp-mode  (pull lisp-modes))\n  (ref subpar-command (pull subpar.core))\n\n  (ref subpart (lambda [cmd opt]\n    (return (lambda [cm]\n      (return CodeMirror.Pass) ## make a configuration option\n      (ref mode (cm.getModeAt (cm.getCursor)))\n      (cond (lisp-mode mode.name)  ((subpar-command cmd) cm opt)\n            (else)                 CodeMirror.Pass\n      )\n    ))\n  ))\n  (CodeMirror.commands.update! {\n    ## paredit keys that defer if not in lisp code\n    subpar_backward_delete:        (subpart \"backward_delete\")\n    subpar_forward_delete:         (subpart \"forward_delete\")\n    subpar_forward_delete:         (subpart \"forward_delete\")\n\n    subpar_open_bracket:           (subpart \"open_expression\" \"()\")\n    subpar_open_square_bracket:    (subpart \"open_expression\" \"[]\")\n    subpar_open_braces:            (subpart \"open_expression\" \"{}\")\n\n    subpar_close_bracket:          (subpart \"close_expression\" \")\")\n    subpar_close_square_bracket:   (subpart \"close_expression\" \"]\")\n    subpar_close_braces:           (subpart \"close_expression\" \"}\")\n\n    subpar_double_quote:           (subpart \"double_quote\")\n\n    subpar_forward:                (subpart \"forward\")\n    subpar_backward:               (subpart \"backward\")\n    subpar_backward_up:            (subpart \"backward_up\")\n    subpar_forward_down:           (subpart \"forward_down\")\n    subpar_backward_down:          (subpart \"backward_down\")\n    subpar_forward_up:             (subpart \"forward_up\")\n\n    subpar_backward_barf:          (subpart \"backward_barf\")\n    subpar_backward_barf:          (subpart \"backward_barf\")\n    subpar_backward_barf:          (subpart \"backward_barf\")\n\n    subpar_forward_barf:           (subpart \"forward_barf\")\n    subpar_forward_barf:           (subpart \"forward_barf\")\n\n    subpar_backward_slurp:         (subpart \"backward_slurp\")\n    subpar_backward_slurp:         (subpart \"backward_slurp\")\n    subpar_backward_slurp:         (subpart \"backward_slurp\")\n\n    subpar_forward_slurp:          (subpart \"forward_slurp\")\n    subpar_forward_slurp:          (subpart \"forward_slurp\")\n\n    subpar_splice_delete_backward: (subpart \"splice_delete_backward\")\n    subpar_splice_delete_forward:  (subpart \"splice_delete_forward\")\n    subpar_splice:                 (subpart \"splice\")\n    subpar_indent_selection:       (subpart \"indent_selection\")\n\n    run_selection:                 run_selection\n  })\n  ))\n\n  ## elm script has a bug - restore for a later version.\n  ## tern is for javascript features - overrides console.log\n  (ref build-base (lambda [target-repo] (using [code-builder]\n    (return (code-builder target-repo \"codemirror\" [[\n      {repo: \"codemirror/CodeMirror\" files: [[\n        {base: \"lib\" include: '/codemirror\\.(js|css)$/'}\n        {base: \"addon/mode\" include: '/^simple.js$/'}\n        {base: \"keymap\"}\n        {base: \"addon\" exclude: '/test.js$|node.js$|standalone.js$|\\/tern\\//'}\n        {base: \"mode/htmlmixed\" include: '/css$|js$/'}\n        {base: \"mode/javascript\" include: '/css$|js$/'}\n        {base: \"mode/css\" include: '/css$|js$/'}\n      ]]}\n      {repo: \"achengs/subpar\" files: [[\n        {base: \"resources/public/js\" include: '/subpar.core.js/'}\n      ]]}\n    ]]))\n  )))\n  (ref build-themes (lambda [target-repo]\n    (return (code-builder target-repo \"codemirror-themes\" [[\n      {repo: \"codemirror/CodeMirror\" files: [[\n        {base: \"theme\"}\n      ]]}\n    ]]))\n  ))\n  (ref build-mode (lambda [target-repo]\n    (return (code-builder target-repo \"codemirror-modes\" [[\n      {repo: \"codemirror/CodeMirror\" files: [[\n        {base: \"mode\" exclude: '/htmlmixed|javascript|css|elm.js$|test.js$/'}\n      ]]}\n    ]]))\n  ))\n  (ref build (lambda [target-repo]\n    (return (promise.all build-base build-themes build-mode))\n  ))\n\n  (lispz.css \"ext/codemirror.css\")\n  (when (net.script \"ext/codemirror.js\" (=> window.CodeMirror))\n    (ref modes-loaded (net.script \"ext/codemirror-modes.js\"\n      (=> CodeMirror.modes.z80)\n    ))\n    (when modes-loaded\n      (stateful.morph! CodeMirror.commands)\n      (CodeMirror.commands.update! extra-commands)\n      (init-lispz-mode)\n      (export {options open close set-mode build})\n    )\n  )\n  (when-rejected (export { build }))\n  (delay 100 (lispz.css \"ext/codemirror-themes.css\"))\n)\n"

lispz_modules['compilers']="### ref: (compilers.add source-type dest-type compiler)\n  e.g. (compilers.add \"less\" \"css\" (promise.callback [src filename]\n         (less.render src { filename } (lambda [err output]\n           (callback err ((or output {}).css))\n         ))\n       ))\n###\n(ref add (lambda [source-type ext compile]\n  (compilers.update! source-type { ext compile })\n))\n\n### ref: (compilers.run js)\n  e.g. (compilers.run (compilers.lispz.compile source))\n###\n(ref run (lambda [js] ((new Function js))))\n\n(ref compilers (stateful {\n  run add\n\n  lispz: { compile: (lambda [source name]\n    (lispz.compile (+ source \"\\n\") name)\n  ) ext: \"js\" }\n}))\n(export compilers)\n"

lispz_modules['core']="### spec: Modules >> Module Structure\n\nAll Lispz source files are modules. They are loaded on first request by client code. Subsequent requests returns a cached reference to the exports.\n###\n### spec: Modules >> Module Usage\n\nEvery module must include an export statement including a dictionary of symbols to be exported\n\n    (ref one (lambda [] ...)\n    (ref two 22)\n    (export {one two})\n\nIf a module requires other asynchronous operations it can defer the export statement until they are ready.\n\n    (lispz.script \"ext/jquery.js\" (lambda [] (export { ... })))\n\nTo access external modules, wrap your code in 'using'. Data and functions exported from a module are linked to the import name.\n\n    (using [dict net list]\n      (ref combined (dict.merge d1 d2 d3))\n    )\n\n...and that is all there is to it.\n###\n(macro using [modules *on_ready] ';' (lispz.load (#join '' '\"' modules '\"')\n  (lambda (#requires modules) *on_ready)\n))\n### Modules must export to continue processing ###\n(macro export [exports] (#join '' '__module_ready__(' exports ')'))\n\n### ref: (try actions error) ## error has error reference set\n    e.g. (try (do *body) (console.log error))\n###\n(macro catch-errors [actions on-error]\n  (#join '' 'try{' actions '}catch(error){' on-error '}')\n)\n\n### spec: developer >> debug\n  `(debug)` is a development helper macro. It will print a stack trace\n  and the contents of any parameters on the console. If you left-align it\n  then it will be easy to find later to delete.\n###\n### spec: debug\n  (describe \"(debug [p1, p2, ...]) ## macro to display stack and messages\" (lambda []\n    (it \"displays a stack trace and the parameters provided\" (lambda []\n      (spy-method console trace)\n      (debug \"multiple\" \"parameters\")\n      ((expect console.trace).toHaveBeenCalled)\n    ))\n  ))\n###\n(macro debug [*msg] (console.trace (#join ',' *msg)))\n\n### spec: basic >> functions >> Variable Parameter Lists\n    Like JavaScript, lispz function definitions specify a fixed number of arguments.\n    To gain access to the full list of arguments, use *arguments, with a starting index.\n\n        (lambda [type rest] (console.log type \"=\" (*arguments 1)))\n###\n(macro *arguments [from] (lispz.slice arguments from))\n\n### spec: basic >> References\n  @TODO\n###\n(macro ref [name value]\n  (#join '' '(_res_=(' name '=' value '))')\n  (#ast add_reference name)\n)\n\n### spec: basic >> References >> Global References\n  @TODO\n###\n(macro global [name value]\n  (#join '' 'lispz.globals.' name '=' value)\n  (macro name [&params] (#join '' '(_res_=lispz.globals.' name '(' &params '))'))\n)\n\n### spec: basics -- Conditionals\n    Lispz boasts only one traditional conditional operator plus a number of\n    macros for conditional assignment and function return. The operator,\n    cond takes pairs of lists where the first is the condition and the\n    second the action. Evaluation stops after the first true condition.\n    There is an else macro that evaluates to true to catch situations not\n    covered specifically. The default? function takes a value and returns\n    it if it exists and is not empty, otherwise it returns the default value.\n\n        (cond (is v \"One\")  1\n              (not v)       0\n              (else)       -1\n        )\n\n    Because conditionals work with list pairs, it is necessary to wrap the actions\n    if there are more than one. Lispz provides 'do' for that.\n\n        (cond ok (do (finish-up) true))\n\n    The standard conditional tests (< > <= >=, etc) are augmented by aliases (is isnt not).\n###\n(macro cond [*list]\n  ((lambda\n    (#join '' ';switch(false){case !(' (#pairs *list '):return ' ';case!(') '}')\n    (return null)\n  ) arguments)\n)\n(macro else 'true')\n\n### spec: basics >> Operators ###\n(macro not [value] (#join '' '!(' value ')'))\n(macro instance-of [type obj] (#join '' '(' obj ' instanceof ' type ')'))\n\n(macro closure [?params *body] ((lambda *body) ?params))\n\n### spec: basic >> do\n###\n(macro do [*body] ((lambda *body) arguments))\n\n### spec: function\n  (describe \"(lambda [p1 p2 ...] ...) ## function definition\" (lambda []\n    (it \"defines an anonymous function that can be called\" (lambda []\n      (ref f1 (lambda [a b] (return (* a b))))\n      (ref result (f1 2 3))\n      ((expect result).toBe 6)\n    ))\n    (it \"has optional parameters\" (lambda []\n      (ref f2 (lambda (return 333)))\n      (ref result (f2))\n      ((expect result).toBe 333)\n    ))\n  ))\n  (describe \"(lambda [p1 p2 ...] ...) ## alternate function definition\" (lambda []\n    (it \"defines an anonymous function that can be called\" (lambda []\n      (ref f1 (lambda [a b] (return (* a b))))\n      (ref result (f1 2 3))\n      ((expect result).toBe 6)\n    ))\n    (it \"has optional parameters\" (lambda []\n      (ref f2 (lambda [] (return 222)))\n      (ref result (f2))\n      ((expect result).toBe 222)\n    ))\n  ))\n###\n\n### spec: basic >> Retrieval - can be used for objects and arrays\n  @TODO\n###\n(macro get [dict *key] (#join '' '(_res_=' dict '[' (#join '][' *key) '])'))\n\n### spec: conditional processing ###\n(macro empty? [list] (not list.length))\n(macro defined? [field] (!== (typeof field) \"undefined\"))\n\n\n(macro new [cls *params] (#join '' '(_res_=(new ' cls '(' (#join ',' *params) ')))'))\n###\n# Use contain to contain state changes. Any var inside a contain can be changed\n# no matter how many times the contain is called concurrently. It is also allows\n# the passing in of variables that are effectively copied and cannot be changed\n# from outside.\n###\n(macro contain [contain#args *contain#body]\n  ((lambda contain#args *contain#body) contain#args)\n)\n\n(using [fp] (using [stateful]\n  ### ref: (once function) ## lazy evaluation\n    e.g. (ref read-it (once (promise ...))) ... (when (read-it) ...)\n  ###\n  (global #once (lambda [lazy-expression]\n    (ref first-time (=>\n      (ref evaluated-value (lazy-expression))\n      (action.update! { func: (=> evaluated-value) })\n      evaluated-value\n    ))\n    (ref action (lispz.globals.stateful\n      { func: first-time when: (new Date) }))\n    (=> (action.func))\n  ))\n  (macro once [*body] (lispz.globals.#once (=> *body)))\n\n  (using [promise counters] (export {}))\n))\n"

lispz_modules['counters']="### spec: Basic >> Keeping Count\n###\n(macro delay [ms *body] (setTimeout (=> *body) ms))\n\n(macro yield [*body] (delay 0 *body))\n\n(global counter! (lambda\n  (ref count (stateful {to: 0}))\n  (lambda\n    (count.update! \"to\" (+ count.to 1))\n    (return count.to)\n  )\n))\n### (unique base-string) ## used to make unique strings from one base\n  (lambda (ref unique-tag (unique! \"tag\") (lambda (unique-tag)))\n###\n(global unique! (lambda [base]\n  (ref counter (counter!))\n  (lambda\n    (ref uid (counter))\n    (cond\n      (is uid 1)  base\n      (< uid 10)  (+ base \"-0\" uid)\n      (else)      (+ base \"-\" uid)\n    )\n  )\n))\n\n(global countdown! (lambda [from by]\n  (ref count (stateful {from}))\n  (return (lambda []\n    (from.update! \"from\" (- count.from by))\n    (return (<= count.from 0))\n  ))\n))\n\n(global wait-for (promise [test max-ms]\n  (ref timed-out (countdown! (or max-ms 5000) 10))\n  (ref waiter (lambda []\n    (cond\n      (test)      (resolve-promise)\n      (timed-out) (reject-promise)\n      (else)      (delay 10 (waiter))\n    )\n  )) (waiter)\n))\n\n###\n# Return a random integer between 0 and the range given\n###\n(global random (lambda [range] (return (Math.floor (* (Math.random) range)))))\n\n### spec: Counters >> UUID\n# Generate a fairly unique ID - at least as unique as Math.random can make it.\n###\n(global uuid (=>\n  (\"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace '/[xy]/g' (=>\n    (ref r = (Math.floor (* (Math.random) 16)))\n    ((cond (is @ \"x\") r (else) (| (& r 0x3) 0x8)).toString 16)\n  ))\n))\n(export {})\n"

lispz_modules['dev']="(using [github riot list dict]\n  (ref manifest (lambda\n    (ref text (stateful [\"CACHE MANIFEST\"]))\n    (lispz.manifest.forEach (lambda [uri] (text.push! uri)))\n    (text.push! \"NETWORK:\" \"*\")\n    (return (text.join \"\\n\"))\n  ))\n  ### Package Lispz for distribution ###\n  (ref package (lambda [repo-name]\n    (package-repo (github.fs repo-name (first (repo-name.split \"/\"))))\n  ))\n  (ref package-repo (lambda [repo]\n    (ref group (lambda [tree]\n      (ref files (Object.keys tree))\n      (ref modules (files.filter (=>\n        (is \"lispz\" (last (@.split \".\")))\n      )))\n      (ref riots   (files.filter (=>\n        (is \"riot.html\" ((slice (@.split \".\") -2).join \".\"))\n      )))\n\n      (promise.resolved {\n        modules:  (modules.map (=> ((slice (@.split \".\") 0 -1).join \".\")))\n        riots:    (riots.map   (=> ((slice (@.split \".\") 0 -2).join \".\")))\n      })\n    ))\n    (ref stringify (=>\n      (return ((@.replace '/[\\\\\"]/g' \"\\\\$&\").replace '/\\n/g' \"\\\\n\"))\n    ))\n    (ref load-module (lambda [name]\n      (ref uri (+ name \".lispz\"))\n      (when (repo.read> uri) [text]\n        [[\"\\nlispz_modules['\" name \"']=\\\"\" (stringify text) \"\\\"\\n\"]]\n      )\n    ))\n    (ref build-modules (lambda [names]\n      (return (promise.all (names.map load-module)))\n    ))\n\n    (ref load-riot (lambda [name]\n      (when (repo.read> (+ name \".riot.html\")) [text]\n        [[\"\\n\\n/*\" name \"*/\\n\\nlispz.tags['\" name \"']=\\\"\"\n          (stringify text) \"\\\"\\n\"]]\n      )\n    ))\n    (ref build-riots (lambda [names]\n      (return (promise.all (names.map load-riot)))\n    ))\n\n    (ref lispz-js    (repo.read> \"lispz.js\"))\n    (ref groups      (when repo.entries> (group @)))\n    (ref modules     (when groups  (build-modules @.modules)))\n    (ref riots       (when groups  (build-riots @.riots)))\n\n    (when (promise.all modules lispz-js riots) [sources]\n      (ref  code  (list.flatten [[\"window.lispz_modules={}\\n\" sources]]))\n      (return (repo.write> \"ext/lispz.js\" (code.join \"\") \"lispz release code\")\n      )\n    )\n  ))\n\n  ### Distribution ###\n  (ref distribute (lambda [target-repo]\n    ## @TODO\n  ))\n\n  (export {manifest package distribute})\n)\n"

lispz_modules['dexie']="### spec: Libraries >> Dexie\nDexie.js is a wrapper library for indexedDB - the standard database in the browser.\n\nhttps://github.com/dfahlander/Dexie.js\n###\n\n(ref build (lambda [target-repo] (using  [code-builder]\n  (code-builder target-repo \"dexie\" [[\n    {repo: \"dfahlander/Dexie.js\" files: [[\n      {base: \"dist/latest\" include: '/Dexie.js$/'}\n    ]]}\n  ]])\n)))\n\n(lispz.script \"ext/dexie.js\" (lambda (export { build })))\n"

lispz_modules['dict']="### spec: lists >> dict -- The Associative Array List (Dictionary)\n\nAre also called dictionaries or hashmaps. Because lispz is a functional language it is not\nuncommon for functions to return a dictionary of values. To make them clearer, if a key is\nsupplied without a following colon then it is placed into the dictionary with a value of the same name.\n\n    (ref exported-method-1 (lambda [] ...))\n    (ref key \"whatever I want\"}\n    (export {exported-method-1 key error: false date: (new Date))\n\nwill create a JavaScript dictionary of the form\n\n    (ref exporting {exported_method_1: exported_method_1, key: key, error: false, date: (new Date)})\n\naccess with a key is identical to arrays except that it is a key rather than an index.\nIf the key is known, using dot syntax is clearer\n\n    exporting.error\n    (get exporting key)\n###\n\n### spec: lists >> dict >> Internals >> Insert\nDictionary merges and inserts take a list of dictionaries in order to push to the target.\nThis means that when they have common keys, the last dictionary that has the key takes\nprecedence.\n\n    ## command-line options overwrite config options of the same name. If neither is\n    ## found, the default option is used.\n    (dict.merge default-options config-file-options cl-options)\n###\n(ref insert (lambda [target dictionaries]\n  (ref target (stateful target))\n  (dictionaries.forEach (lambda [dictionary]\n    (target.update! dictionary)\n  ))\n  (return target)\n))\n\n### spec: lists >> dict >> Merging Dictionaries\nThere is often need to merge multiple dictionaries together to create a new combined one.\n\n    (ref big-dict (dict.merge dict-1 dict-2 dict-3))\n###\n(ref merge (lambda [dictionaries]\n  (return (insert {} (*arguments)))\n))\n\n### spec: lists >> dict >> Inserting One Dictionary in Another\n**Warning** This is not referentially transparent\n\n    (dict.insert! dict-1 dict-2 dict-3)      ## changes dict-1\n###\n(ref insert! (lambda [target dictionaries]\n  (return (insert target (*arguments)))\n))\n\n### spec: lists >> dict >> Create a Dictionary from a List\n    (ref list [[{key: 1 value: 2} {key: 3 value: 4}]]\n    (dict.from-list list \"key\")    # {1: {key: 1 value: 2} 3: {key: 3 value: 4})\n###\n(ref from-list (lambda [list key]\n  (ref dictionary (stateful))\n  (cond list (list.forEach (lambda [item]\n    (dictionary.update! (get item key) item)\n  )))\n  (return (merge dictionary))\n))\n\n### spec: lists >> dict >> For Each Entry...\n    (dict.for-each dict-1 (lambda [key value] ...))\n###\n(ref for-each (lambda [dict action=>]\n  ((Object.keys dict).forEach (lambda [k] (action=> k (get dict k))))\n))\n\n### spec: lists >> dict >> Morphing dictionary into an Array\n###\n(ref map (lambda [dict action=>]\n  (return ((Object.keys dict).map (lambda [k] (action=> k (get dict k)))))\n))\n\n### ref: (list.set array) ## returns a dictionary of key=key pairs\n    e.g. (list.set [[1 1 2 2]]) ## ==> { 1:1 2:2 }\n###\n(ref set (lambda [array]\n  (ref dictionary (stateful))\n  (cond array (array.forEach (lambda [item]\n    (dictionary.update! item item)\n  )))\n  (merge dictionary)\n))\n\n(ref filter (lambda [dict action=>]\n  (return ((Object.keys dict).filter (lambda [k] (return (action=> k (get dict k))))))\n))\n\n### spec: lists >> dict >> Check a Dictionary for an Entry\n###\n(ref contains (lambda [test against]\n  (return (#join '' '(' test ' in ' against ')'))\n))\n\n(export { merge from-list insert! for-each map filter contains set })\n"

lispz_modules['diff_match_patch']="### spec: Libraries >> Diff-Match-Patch\nThis is an unofficial mirror of the JavaScript version of the google-diff-match-patch library.\n\nhttps://github.com/tanaka-de-silva/google-diff-match-patch-js\n###\n(ref build (lambda [target-repo built=>] (using [code-builder]\n  (return (code-builder target-repo \"diff_match_patch\" [[\n    {repo: \"tanaka-de-silva/google-diff-match-patch-js\" files: [[\n      {base: \"\" include: '/^diff_match_patch_uncompressed.js$/'}\n    ]]}\n  ]]))\n)))\n(lispz.script \"ext/diff_match_patch.js\" (lambda (export { build })))\n"

lispz_modules['doc/bootstrap']="### spec: Bootstrap\nThe most popular HTML, CSS, and JavaScript framework for developing responsive, mobile first projects on the web.\n\n  Bootstrap is a popular CSS framework open sourced by Twitter. It includes skins\n  so all bootstrap driven sites do not have to look alike. It provides support\n  for differing screen sizes and is relatively mobile friendly.\n\nhttp://getbootstrap.com\nhttps://github.com/twbs/bootstrap\n###\n(using [net cdnjs message list]\n  (ref bootswatch-themes [[\"cerulean\" \"cosmo\" \"cyborg\" \"darkly\" \"flatly\"\n    \"journal\" \"lumen\" \"paper\" \"readable\" \"sandstone\" \"simplex\" \"slate\"\n    \"spacelab\" \"superhero\" \"united\" \"yeti\" \"default\"]])\n\n  (ref build (lambda [target-repo]\n    (return (promise.all\n      (code-builder target-repo \"bootstrap\" [[\n        {repo: \"twbs/bootstrap\" files: [[\n          {base: \"dist\" exclude: '/\\.map$|\\.min\\.|npm.js$/'}\n          {base: \"dist/fonts\" copy-to: \"fonts\"}\n        ]]}\n      ]])\n      (bootswatch-themes.map (lambda [theme]\n        (return (cdnjs.build target-repo (+ \"bootstrap-\" theme) [[\n          {repo: \"bootswatch\" files: [[{include: (+ theme \"/bootstrap.css\")}]]}\n        ]]))\n      ))\n    ))\n  ))\n\n  (lispz.css \"ext/bootstrap.css\")\n  (ref themes bootswatch-themes)\n  (ref random-theme (dot (random themes.length) in bootswatch-themes))\n\n  ### spec: Bootstrap >> Bootswatch\n  # https://bootswatch.com\n  # Loads a bootswatch theme to make the page look different.\n  # If no theme is provided, a random one is selected.\n  ###\n  (message.listen \"bootstrap/change-theme\" (lambda [theme-name]\n    (ref theme\n      (cond (not (defined? theme-name)) (random-theme)\n            (else)                      theme-name\n      )\n    )\n    (net.css (+ \"ext/bootstrap-\" theme \".css\"))\n  ))\n  ### spec: Bootstrap >> modal\n    Open a named modal dialog box and wait for a user response. Options:\n\n    * seed - object to fill modal form fields\n    * attributes - for the element being created\n  ###\n  (ref modal> (promise [name-path opts] (using [riot dom]\n    (ref name (last (name-path.split \"/\")))\n    (ref address (+ \"modal/\" name))\n    (ref show-modal (=> (message.send (+ address \"/show\"))))\n    (cond (get lispz.tags name) (show-modal)\n    (else) ## modals are singletons, load once\n      (when (riot.inject name-path opts.attributes)\n        (show-modal)\n      )\n    )\n    (ref hidden-address (+ address \"/hidden\"))\n    (message.listen hidden-address (=>\n      (message.clear hidden-address)\n      (resolve-promise (dom.scrape-form @.element))\n    ))\n  )))\n  ### ref: (bootstrap.path-to-tree path-list) ## ready for tree or menu\n      item is { divider: true disabled: true title header children: {} }\n      e.g. (bootstrap.path-to-tree [\"a/b\" \"a/c\" \"d/e\" \"f\"])\n  ###\n  (ref path-to-tree (lambda [path-list]\n    ((list.sort path-list).map (=> (@.split \"/\")))\n  ))\n  ### spec: Bootstrap >> loading\n    We know that bootstrap has completed loading\n    when we see _modal_ added to the list of\n    JQuery functions.\n  ###\n  (when (net.script \"ext/bootstrap.js\" (=> (($).modal)))\n    (export { build themes modal> path-to-tree })\n  )\n  (when-rejected (export { build }))\n)\n\n### spec: Bootstrap >> Bootstrap/RIOT/Lispz Combo\n  There is a difference of scope between bootstrap and riot.\n  [Bootstrap](http://getbootstrap.com/) is designed to be used page-wide.\n  Riot is a web component system where each component should be as independent as possible.\n  ###\n  ### spec: bootstrap >> Page Level Bootstrap\n\n  Any single page application that is going to use bootstrap to simplify the UI wraps the contents inside the body with a bootstrap tag. Use an inner page-content tag to allow for fluid layouts - those that change as the window changes size.\n\n      <body>\n        <bootstrap class=riot>\n          <page-content fluid=true>\n            ...\n          </page-content>\n        </bootstrap>\n      </body>\n\n  ###\n  ### spec: Bootstrap >> Bootstrap Themes\n\n  Bootstrap sites do not have to look alike. [Bootswatch](https://bootswatch.com/)\n  provides 16+ free themes, including ones that fit in with Metro, Polymer and Ubuntu:\n\n  > Default, Cerulean, Cosmo, Cyborg, Darkly, Flatly, Journal, Lumen, Paper, Readable,\n  > Sandstone, Simplex, Slate, Spacelab, Superhero, United, Yeti\n\n  To select a theme, send a message to _change-bootstrap-theme_ with the name of the theme\n  to change to. If you don't provide a theme name, a random one is chosen.\n\n  ###\n  ### spec: bootstrap >> Component Specific Bootstrap\n\n  Riot components can include a _style_ section.\n  If you preface all entries with the name of the component then you have\n  name-spaced your css.\n\n      <code-editor>\n        <panel height={ opts.height } heading={ heading } menu={ menu } owner={ _riot_id }>\n          <div name=wrapper class=wrapper></div>\n        </panel>\n        <style>\n          code-editor .wrapper {\n            ...\n          }\n      </code-editor>\n###\n"

lispz_modules['doc/list']="### spec: lists -- Lists and Arrays\n    Lisp was named as a shorter form of 'list processing'. When I first heard of lisp in the early 80's, I did not follow up on it as I did not see the value for my work in a language that gave priority to lists. Who needs specialised list processing when we have loops? This at a time I was using FORTH without thinking that I was treating the stack as a list. Time has moved on (a lot) and with the era of multiple cores starts, functional programming has gained new ground.\n\n    Lispz compiles to JavaScript on the browser, so has very little opportunity at this time to use multiple cores. It will work happily with web workers once they become ubiquitous, but that is more the architecture of the workers than the language to use.\n\n    Enough... on to lists. JavaScript ES5 has already added quite a few referentially transparent list processing functions. In this case it means they will not change the lists provided as input.\n\n        (ref l1 [[1 2 3]]   l2 [[4 5]]   l3 [[6 7]])\n\n        (l1.concat l2 l3)                                               ## [[1 2 3 4 5 6 7]]\n        (l1.indexOf 2 from)                                             ## 1  ## from defaults to 0\n        (li.join \", \")                                                  ## \"1, 2, 3\"\n        (li.lastIndexOf 2 from)                                         ## 1  ## from default to last element\n\n        (l1.every (lambda [item idx lst] (return (< idx 2))))           ## [[1 2]]  ## index, lst are optional\n        (l1.filter (lambda [item idx lst] (return (% idx 2))))          ## [[1 3]]\n        (l1.forEach (lambda [item idx lst] (console.log item)))         ## 1\\n2\\n3\n        (l1.map (lambda [item idx lst] (return (* item 2))))            ## [[2 4 6]]\n        (l1.reduce (lambda [prev item idx lst] (return (+ prev item))) seed)      ## 6 ## seed optional\n        (l1.reduceRight (lambda [prev item idx lst] (return (+ prev item))) seed) ## 6 ## seed optional\n        (l1.slice 1 2)                                                  ## [[2]] ## -ve from end\n        (l1.some (lambda [item idx lst] (is item 4)))                   ## false  ## true if (is item 2)\n\n    The following are not referentially transparent\n\n        (l1.pop)                                                        ## 3  ## (is l1 [[1 2]])\n        (l1.push 88)                                                    ## [[1 2 3 88]]\n        (l1.reverse)                                                    ## (is l1 [[3 2 1]])\n        (l1.shift))                                                     ## 1  ## (is l1 [[2 3]])\n        (l1.sort (lambda [a b] (- b a)))                                ## [[3 2 1]]  ## function optional\n        (l1.splice 1 1 32 33)                                           ## [[1 32 33 3]]  ## idx delcnt adds\n        (l1.unshift 99)                                                 ## [[99 1 2 3]]\n\n    Lispz has less convenient access to specific entries for updates or removals\n\n        (get 1 in l1)                                                   ## 2\n        (update! l1 1 22)                                               ## (is l1 [[1 22 3]])\n\n    And for more functional processing\n\n        (first l1)                                                      ## 1\n        (rest l1)                                                       ## [[2 3]]\n        (last l1)                                                       ## 3\n\n    And others...\n\n        (in l2 2)                                                       ## true\n        (empty? l1)                                                     ## false\n        (slice 1 2)                                                     ## [[2]]  ## works with *arguments\n###\n### spec: lists >> The Functional List\nIn Lispz the braces are reserved for function-like calls - being traditional functions and lisp macros. The atom immediately after the open brace is the name of the function or macro.\n\n    (console.log \"Hello world\")   ## calling a javascript function to write to the console\n    (debug \"Hello world\")         ## a macro that writes the current function call stack then a message\n\nThe first 'atom' can also be an anonymous function.\n\n    ((lambda [] (console.log \"Hello world\")))\n    ## is the same as\n    (ref hw (lambda [] (console.log \"Hello world\")))\n    (hw)\n\nInternally functional lists are either expanded into more lispz statements by a macro or are converted to a Javascript function. The list becomes the function arguments.\n\n    (console.log \"Hello\" \"world\")  ## JS==> console.log(\"Hello\", \"world\")\n\nMacros are amazing things. Addition does not expand to a function but to in-line code:\n\n    (+ 1 2 3) ## JS==> 1 + 2 + 3\n###\n### spec: lists >> The Raw List\n\nAt the risk of repeating myself (and at the risk of repeating myself), Lispz is a lightweight compiler to JavaScript. A raw list is an sequence of atoms. When compiled to Javascript the sequence will be comma separated. It is most commonly used for parameters in a function definition:\n\n    (ref expect (lambda [address listener=>]\n      (add address {once: true listener=>})\n    ))\n\nThe defined function, expect takes 2 parameters, being a string address and a function reference. The => at the end of this function reference is not syntax, just convenience text to show that this is a callback function.\n###\n### spec: lists >> Array as a List\n\nFor a traditional list or array, use [[]]. This will translate into a normal JavaScript array with standard functional support suchs as forEach and map.\n\n    (ref list [[1 2 6 9]])\n    (ref double (list.map [item] (return (* item 2)))) ## JS==> [2, 4, 12, 18]\n\nUse the get command to retrieve entries\n\n    (ref second (get 2 in double))\n\nAll the JavaScript list processing functions (every, filter, forEach, ...) are available. See the [List Processing](list-processing.md) section for more details.\n\nTo see if an array contains an element, use 'in':\n\n    (cond (12 in list) \"has dozen\")\n###\n### spec: lists >> flatten - Flattening Lists of Lists\n###\n(ref flatten (lambda [list]\n  (list.reduce (lambda [a b]\n    (ref bflat (cond (instance-of Array b) (flatten b) (else) b))\n    (return (a.concat bflat))\n  ) [[]])\n))\n### spec: lists >> for-each\n  This is a helper for the JavaScript [].forEach(). It has the advantage that\n  it behaves correctly if the item is not an array by running once for the entry\n  if it is not a falsy.\n###\n(ref for-each (lambda [list action]\n  (cond (not list)               null\n        (instance-of Array list) (list.forEach action)\n        (else)                   (action list)\n  )\n))\n\n### spec: List and dictionary manipulation ###\n(macro length [list] (#join '' list '.length'))\n(macro rest [list] (list .slice 1))\n(macro last [list] (first (list .slice -1)))\n(global slice (lambda [list from to]  (return (lispz.slice.call list from to))))\n\n### spec: lists >> contains\n###\n(ref contains (lambda [substr str] (return (isnt -1 (str .indexOf substr)))))\n\n### spec: lists >> sort\n###\n(ref reverse (lambda [list]\n  (return ((slice list).reverse))\n))\n\n(export {flatten for-each contains reverse})\n"

lispz_modules['doc/message']="### spec: async >> Messaging\n  Lispz includes a complete decoupled communications solution based on messaging.\n  The base version is in-browser, but the API is designed to work across systems\n  with RESTful or WebSockets. The UI components use messaging to communicate\n  between components that are not linked, so cannot make more direct connections.\n\n\n  If it is possible that a client will send an important request before the\n  service has had the opportunity to initialise, wrap 'send' in 'wait-for':\n\n      (message.wait-for \"code-editor/scratch\" (lambda\n        (message.send \"code-editor/scratch\"\n          {action: \"open\" key: \"scratchpad.lispz\" contents: null}\n        )\n\n  'dispatch' uses an entry called 'action' to decide on which function to call.\n  For raw processing, use 'listen' instead. The following example changes the\n  left padding on a DOM element if asked.\n\n      (message.listen \"dom/page-content-wrapper-padding\" (lambda [px]\n        (set! tag.page-content-wrapper.style.paddingLeft (+ px \"px\"))\n\n  For a one-off message, use 'expect' rather than 'listen':\n\n      (message.expect \"editor-loaded\" (lambda ...)\n\n  Lispz uses exchanges defined as part of the address. Plain string addresses as\n  used so far will use a local in-browser exchange. The address can include\n  details that will define different exchanges (when implemented).\n\n  It is possible to remove listeners if you have access to the callback used to\n  create the listener\n\n      (message.remove \"my-message\" my-message-listener=>)\n\n  Messages also includes a common log processor. The following two calls behave\n  in an identical manner.\n\n      (message.log \"message: message-text\")\n      (message.send \"logging\" {level: \"message\"  text: \"message-text\"})\n\n  The default processor sends them to the browser console. Add additional\n  listeners for modal dialogs, error messages, etc.\n###\n(using [list]\n  (ref store (stateful)) (ref expecting   (stateful))\n  (ref links (stateful)) (ref dispatchers (stateful))\n  (ref in-store (pull store))\n  (ref get-link (pull links))\n\n  (ref exchange (lambda [address]\n    (or (in-store address) (do\n      (ref envelopes (stateful []))\n      (store.update! address envelopes)\n      envelopes\n    ))\n  ))\n\n  (ref add (lambda [address envelope]\n    (ref envelopes (exchange address))\n    (envelopes.push! envelope)\n    (ref expected-mail-action (get expecting address))\n    (cond (and (is envelopes.length 1)  (get expecting address))\n          (do (expected-mail-action) (delete expected-mail-action)))\n  ))\n\n  (ref ready (promise [address]\n    (ref envelopes (exchange address))\n    (cond (length envelopes)\n      (promise.resolved)\n    (else)\n      (expecting.update! address resolve-promise)\n    )\n  ))\n\n  ## remove a recipient from all attached addresses\n  (ref remove (lambda [address recipient]\n    (ref envelopes (exchange address))\n    (store.update! address\n      (stateful (envelopes.filter (lambda [possibility]\n        (return (isnt recipient possibility)))\n      ))\n    )\n  ))\n\n  ## clear all listeners for an address\n  (ref clear (lambda [address] (store.update! address (stateful []))))\n\n  (ref link (lambda [primary secondary]\n    (ref primary-links (or\n      (get-link primary)\n      (links.update! primary (stateful [])))\n    )\n    (primary-links.push! secondary)\n  ))\n\n  (add-execution-context-logger \"message.send\" (lambda [context error-args]\n    (return (+ \"to \" context.address \", packet \" context.packet))\n  ))\n  ###\n  (ref send (promise [address packet]\n    (execution-context {context: \"message.send\" address packet}\n      ## take a copy so that it does not change during processing\n      (ref result-promises (stateful []))\n      (ref sender (lambda [recipient]\n        ## yield so that we don't lock up the current thread\n        (result-promises.push! (recipient.listener=> packet))\n        (cond recipient.once (remove recipient))\n      ))\n      (ref envelopes (exchange address))\n      (envelopes.forEach sender)\n      (ref secondaries (or (get-link address) [[]]))\n      (list.for-each secondaries (lambda [link] (send link packet)))\n      (when (promise.all result-promises) [results]\n        (resolve-promise (list.squash results))\n      )\n    )\n  ))\n  ###\n  (ref send (lambda [address packet]\n    (execution-context {context: \"message.send\" address packet}\n      ## take a copy so that it does not change during processing\n      (ref result (stateful))\n      (ref sender (lambda [recipient]\n        (result.update! \"contents\" (recipient.listener=> packet))\n        (cond recipient.once (remove recipient))\n      ))\n      (ref envelopes (exchange address))\n      (envelopes.forEach sender)\n      (ref secondaries (or (get-link address) [[]]))\n      (list.for-each secondaries (lambda [link] (send link packet)))\n    ) (return (promised result.contents))\n  ))\n\n  (ref expect (lambda [address listener=>]\n    (add address {once: true listener=>})\n  ))\n\n  (ref listen (lambda [address listener=>]\n    (add address {listener=>})\n  ))\n\n  (add-execution-context-logger \"message.dispatch\" (lambda [context error-args]\n    (return (+ \"received from \" context.address \" packet \" context.packet))\n  ))\n  ### spec: async >> Messaging >> dispatch\n  Here a code editor will wait on messages to open a new 'file'. The message\n  includes a name unique to each code editor. The dictionary at the end can\n  include any number of named requests. Each associated function takes a packet\n  whose content format is known by clients and services.\n\n      (using [message]\n        (ref open (lambda [packet] ...)\n        (message.dispatch (+ \"code-editor/\" opts.name) { open })\n\n  The client will send a command to open a new file for display. If the editor\n  is called 'scratch':\n\n      (message.send \"code-editor/scratch\"\n        {action: \"open\" key: \"scratchpad.lispz\" contents: null}\n      )\n\n  In most cases it is easier to use a connector function\n\n      (ref scratchpad (message.connect \"code-editor/scratch\"))\n      ...\n      (scratchpad.open {key: \"scratchpad.lispz\" contents: null})\n  ###\n  (ref dispatch (lambda [address actions]\n    (ref get-action (pull actions))\n    (dispatchers.update! address actions)\n    (listen address (lambda [packet]\n      (execution-context {context: \"dispatch\" address packet}\n        (ref action (get-action packet.action))\n        (cond (not action) (promise.resolved false))\n      )\n      (action packet)\n    ))\n  ))\n  (ref connect (lambda [address] (get dispatchers address)))\n\n  (ref log (lambda [text]\n    (ref parts (text.split '/\\s*:\\s*/'))\n    (cond (is 1 parts.length) (parts.unshift \"message\"))\n    (send \"logging\" {level: (first parts) text: (second parts)})\n  ))\n\n  (listen \"logging\" (lambda [packet]\n    (console.log packet.level \"-\" packet.text)\n  ))\n\n  (export {exchange send expect listen dispatch ready clear link connect})\n)\n"

lispz_modules['doc/promise']="### spec: async >> Promises\nES2015 has introduced native promises into the language. As of November 2015 it\nis available on all mainstream browsers. Even if not, there are shims that work\nin an identical(ish) manner.\n\nFunctions that want to return information in an asynchronous manner return a\npromise object. This object can be passed around and whoever needs the data it\nwill or does contain can ask for it with a callback function.\n\nA function that creates a promise uses the 'promise' keyword instead of 'function'.\nWhen the promise is fulfilled it will call (resolve-promise data). If it fails\nit calls (reject-promise err).\n\n    (ref read (promise [addr param1 param2]\n      (http-get (+ addr \"?&\" param1 \"&\" param2) (lambda [err response]\n        (cond err    (reject-promise err)\n              (else) (resolve-promise response)\n        )\n      ))\n    ))\n\nIn _promise_ the function is run immediately. In many situations it is nice to\nhave a promise that only runs when it is first needed. You may, for example,\ncreate a file object that may or may not ever ask a server for the contents.\nThis is where lazy evaluation using _once_ shines.\n\n    (ref file {\n      read: (promise.deferred [addr param1 param2]\n        (http-get (+ addr \"?&\" param1 \"&\" param2) (lambda [err response]\n          (cond err    (reject-promise err)\n                (else) (resolve-promise response)\n          )\n        ))\n      )\n    })\n    ...\n    ## This will trigger a server request...\n    (when file.read [response] (console.log response))\n\nBecause it is common to turn a callback into a promise, lispz provides a helper\nmacro. The following provides identical functionality. One of the benefits of a\nlanguage with real macros :)\n\n    (ref read (promise.callback [addr param1 param2]\n      (http-get (+ addr \"?&\" param1 \"&\" param2) callback)\n    ))\n\nNow that we have a promise, we can use it just like a callback if we want:\n\n    (ref reading (read \"http://blat.com/blah\" 1 2))\n    (when reading [result] (return (process result)))\n    (promise.failed reading [err] (console.log \"ERROR: \"+err))\n\nEven without further knowledge, promises clean up errors and exceptions. If you do not catch errors, exceptions thrown in the asynchronous function can be caught in the code containing the promise.\n\nThe power of promises starts to become clearer with the understanding that 'when' can return a promise.\n\n    (ref processed (when reading [result] (return (process result))))\n    (when processed (console.log \"All done\"))\n\nSo far this adds very little at the cost of a relatively large supporting library. if we start thinking functionally instead of sequentially, promises provides a way to clarify our code (a little).\n\n    # change branch we will be working with\n    (ref update-mode (github.update lispz-repo))\n    # Once in update mode we can retrieve lispz.js and ask for a list of other file in parallel\n    (ref lispz-js    (when update-mode [] (read-file \"lispz.js\")))\n    (ref listing     (when update-mode [] (github.list-dir lispz-repo \"\")))\n    # We can only sort files once we have a listing from the server\n    (ref groups      (when listing [files] (group files)))\n    # but then we can process the different groups in parallel (retrieving source as needed)\n    (ref modules     (when groups [files] (return (build-modules files.modules))))\n    (ref riots       (when groups [files] (return (build-riots files.riots))))\n\n    # Now to pull it all together into a single file\n    (ref  source     (stateful.array [[\"window.lispz_modules={}\"]]))\n    # promise.sequence forces the order.\n    (ref all-loaded  (promise.sequence\n      (when modules  [sources] (source.concat sources) (return (promise.resolved))\n      # lisp.js is added after modules and lisp-js are resolved\n      (when lispz-js [code]    (source.push! code) (return (promise.resolved))\n      # riot tags are added after lisp.js and lisp-js is added and riots promise is resolved\n      (when riots    [sources] (source.concat sources) (return (promise.resolved))\n    ))\n    # Only write the result when the sequence above is complete\n    (return (when all-loaded (write-lispz)))\n    # returns a promise that is complete once the results are written\n\nIn summary we have\n\n1. **(promise [params...] ...)** is a macro that generates a function that returns a promise\n  1. **(resolve-promise results...)** sets results used in **when [results...] ...** macros\n  2. **(reject-promise err)** sets results used in **(promise.failed [err] ...)** macros\n2. **(promise.callback [params...] ...)** is a macro to creates promises from traditional callbacks\n  1. **callback** is a function reference to use where callbacks would normally be defined\n3. **(promise.resolved results)** Will return a promise that will always provide the results supplied to when. Use it to turn a synchronous function into a promise to use in sequences.\n4. **(when a-promise [results...] ...)** is a macro that works like a function where the function body is executed with the results supplied once (and if) the promise is resolved. If a **when** statement returns a promise it can be used for chaining.\n5. **(promise.failed a-promise [err] ...) is a macro that works like a function where the function body is executed if any of a set of chained promises uses **reject-promise** to indicate an error.\n6. **(promise.all promise-1 promise-2 [[promises]])** will return a promise that is fulfilled when all the promises specified are resolved or rejected. It will flatten arrays of promises.\n7. **(promise.sequence promise-1 promise-2 [[promises]])** will return a promise that is fulfilled when all the promises specified are resolved or rejected. Unlike **all**, each promise is triggered when the preceding promise is resolved.\n\n## Benefits\n1. Separates cause and effect more clearly\n2. Results are available even it the promise is resolved before inspection\n3. You can pass around a promise just like the data it will contain\n4. Handles exceptions in a structured way\n\n## Disadvantages\n2. Still fairly highly coupled\n3. Only allows one action - not for repetitive events\n4. Developer view needs to change from sequential perspective\n5. Being selective about errors and exceptions is painful. Once a promise is resolved it cannot change. Any promises that rely on a rejected promise will themselves be rejected causing a cascade of failures. To be selective you need to wrap a promise catch in an outer promise and resolve the outer one if the error itself can be resolved. Don't forget to resolve the outer promise with the data from the inner one when there are no errors.\n###\n(global #prepare-promise (lambda\n  (ref callbacks (stateful {ok: (lambda) fail: (lambda)}))\n  (ref pledge (stateful.morph!\n    (new Promise (lambda [ok fail] (callbacks.update! {ok fail})))\n  ))\n  (ref resolve (lambda (callbacks.ok.apply null (*arguments 0))))\n  (ref reject (lambda [err] (callbacks.fail err)))\n  (return { pledge resolve reject })\n))\n(global #action-promise (lambda [context promise-body]\n  (context.pledge.update! \"execution_context\" lispz.execution-context)\n  (#join '' 'try{' (promise-body context.resolve context.reject) '}catch(err){'\n    (lispz.log-execution-context context.pledge.execution-context [[\"own-promise\"]])\n    (lispz.log-execution-context lispz.execution-context [[\"in-promise\"]])\n    (context.reject err) '}'\n  )\n  (return context.pledge)\n))\n(global #deferred-promise (lambda [promise-body]\n  (ref context (#prepare-promise))\n  (context.pledge.update! {deferred: (lambda\n    (return (#action-promise context promise-body))\n  )})\n  (return context.pledge)\n))\n(global promise {})\n\n(macro promise [?params *body] (lambda ?params\n  (return (#action-promise (#prepare-promise)\n    (lambda [resolve-promise reject-promise] *body)\n  ))\n))\n(macro promise.deferred [*body]\n  (return #deferred-promise (lambda [resolve-promise reject-promise] *body))\n)\n(macro promise.callback [?params *body] (promise ?params\n  (ref callback (lambda [err result]\n    (cond err    (reject-promise err)\n          (else) (resolve-promise result)\n    )\n  ))\n  *body\n))\n(global promise.resolved (promise [pact] (resolve-promise pact)))\n\n(global promised (lambda [pledge]\n  (cond (and pledge pledge.then) pledge\n        (else)                   (promise.resolved pledge)\n  )\n))\n\n(global #resolve-deferred (lambda [pledge]\n  (cond pledge.deferred (do\n    (ref deferred pledge.deferred)\n    (delete pledge.deferred)\n    (deferred)\n  ))\n  (return pledge)\n))\n\n(macro when [pledge ?params *body]\n  ((#resolve-deferred pledge).then (lambda ?params *body))\n)\n(macro promise.failed [pledge ?errors *body]\n  ((#resolve-deferred pledge).catch (lambda ?errors *body))\n)\n\n(using [list]\n  (global promise.all (=>\n    (return (Promise.all (list.flatten (*arguments 0))))\n  ))\n)\n(global promise.chain (lambda []\n  (ref chain-link (lambda [input functions]\n    (cond (not functions.length) (promised input)\n    (else) (do\n      (ref pledge (promised ((first functions) input)))\n      (when pledge [output] (chain-link output (rest functions)))\n    ))\n  ))\n  (chain-link null (*arguments 0))\n))\n\n(export [])\n"

lispz_modules['doc/riot']="### spec: Libraries >> RIOT\nA React-like, user interface library\n\n[Lispz RIOT Support](riot.spec.lispz)\nhttp://riotjs.com/\nhttps://github.com/riot/riot\n###\n### spec: Riot\n\n[Riot](http://riotjs.com) is a tiny UI library then provides the best of Web components (polymer) and react in a package 15% of the size.\n\nRiot, like web components, each file (of type .riot.html) is a html fragment that also includes style and script elements. Like web components it is based on creating custom tags. This provides clean and readable HTML. Custom tags makes the HTML more readable.\n\nThe *panel* tags is a Riot wrapper around bootstrap panels.\n\nRiot, like React it works with a virtual DOM and only updates changes to the real DOM. Like React it compiles to JavaScript. It can be supported on older browsers.\n\nSmall tight API that provides all needed web component functionality for reactive views, events and routing.\n###\n\n### spec: Riot >> Structure of a RIOT/Lispz Program\n\nRiot components have the extension *.riot.html*. They are loaded from the HTML file or from another component. In the HTML, give a custom tag the class or *riot* and it will load a component file of the same name - including any other tags in the file. The html below will load *bootstrap.riot.html* and *code-editor.riot.html*, while *page-content* does not need a riot class as it is defined withing *bootstrap*.\n\n    <bootstrap class=riot>\n      <page-content fluid=true>\n        <div class=col-sm-6>\n          <code-editor class=riot name=literate height=48% />\n        </div>\n        <div class=col-sm-6>\n          <code-editor class=riot name=code height=48% />\n        </div>\n      </page-content>\n    </bootstrap>\n\nRiot uses plain JavaScript inside {} as a templating solution. The *opts* dictionary matches the attributes when the custom tag is referenced. Any inner tag with a *name* or *id* attribute can be referenced by the same name. Each component has a unique *_id*.\n\nStyles are global (unlike *true* web components). This is easily overcome using explicit name-spacing as above.\n###\n\n### spec: Riot >> Using other languages\n\nScripting can be any language of choice that runs on the browser. JavaScript, Lispz, Es6 (with babel) and CoffeeScript are available out-of-the-box. For the latter two you will need to load the compiler by *(using babel coffeescript)* in the startup code. Other languages can be added as long as they compile code on the browser.\n\n    (set! riot.parsers.js.lispz (lambda [source]\n      (lispz.compile source \"riot-tags\").join \"\\n\")\n    ))\n###\n(using  [jquery net dict dom]\n  ## we need to update the tags cache\n  (stateful.morph! lispz.tags)\n  ### spec: RIOT >> Get Tag Definition by Name\n  ###\n  (ref tag-by-name (pull lispz.tags))\n\n  ## has side-effects as riot caches compile results\n  (ref compile (=> (riot.compile.apply riot ``(*arguments 0))))\n\n  (ref processed-tags (stateful {}))\n  (ref processed-tag  (pull processed-tags))\n\n  (add-execution-context-logger \"riot.load\" (lambda [context error-args]\n    (return (+ \"tag\" context.name \" from \" context.uri))\n  ))\n  (ref child-tags (lambda [html]\n    (ref raw-tags (html.match '/<[^>\\s]+[^>]*?class=[\\'\\\"]riot[\\s\\'\\\"]/g'))\n    ((or raw-tags [[]]).map (=> (last ('/^<(\\S*)/'.exec @))))\n  ))\n  ### spec: RIOT >> load\n    Returns true if tag has been previously loaded. This\n    allows the caller to decided whether to reuse or\n    reinstate.\n  ###\n  (ref load (promise [name uri] (execution-context {context: \"riot.load\" name uri}\n    (ref usings (lambda [tags]\n      (ref new-tags (tags.filter (=>\n        (cond @.length (do\n          (ref processed (processed-tag @))\n          (processed-tags.update! @ true)\n          (not processed)\n        ) (else) false)\n      )))\n      (ref loaded (promise.all (new-tags.map (=>\n        (return (load @))\n      ))))\n      (when loaded (resolve-promise))\n    ))\n\n    (ref compile-and-process (lambda [tag-html]\n      (usings (child-tags (compile tag-html)))\n    ))\n\n    (ref retrieve-and-compile (lambda\n      (ref url\n        (or uri (+ (name.toLowerCase) \".riot.html\"))\n      )\n      (when (net.http-get url) [tag-html]\n        (lispz.tags.update! name tag-html)\n        (compile-and-process tag-html)\n      )\n    ))\n\n    (ref tag-def (tag-by-name name))\n    (cond\n      tag-def   (compile-and-process tag-def)\n      (else)    (retrieve-and-compile)\n    )\n  )))\n\n  (ref build (lambda [target-repo] (using [code-builder]\n    (return (code-builder target-repo \"riot\" [[\n      {repo: \"riot/riot\" files: [[\n        {include: '/^riot\\+compiler.js$/'}\n      ]]}\n    ]]))\n  )))\n  ### spec: RIOT >> mount\n  ###\n  (ref mount (=> (riot.mount *arguments)))\n\n  ### spec: RIOT >> inject\n    Load a named tag if needed, inject an instance into the DOM then mount it.\n    The name can be the name of the file followed by the specific element.\n  ###\n  (ref inject (promise [name-path attributes parent-selector]\n    (ref parts (name-path.split \"/\"))\n    (ref name  (last parts))\n    (ref file (first parts))\n    (ref exists (tag-by-name name))\n    (when (load name (+ file \".riot.html\"))\n      (cond exists (do\n        (ref tags (riot.mount name))\n        (resolve-promise (first tags))\n      ) (else) (do\n        (ref element (dom.element name attributes))\n        (ref parent (or parent-selector \"body\"))\n        (dom.append! parent element)\n        (ref tags (riot.mount element name))\n        (resolve-promise (first tags))\n      ))\n    )\n  ))\n\n  ### spec: riot >> Trigger Display Changes\n    Given a component context called *tag*, it is possible to change context\n    data using the state component.\n\n      <script type=text/lispz>\n        (ref tag (stateful.morph this))\n        ...\n        (ref async-set-title (lambda [title]\n          (tag.update! {title})\n          (tag.update)\n        ))\n      </script>\n\n    For the confused, *update!* changes entries in the stateful context,\n    while *update* is a riot function to update the display for bound\n    data changes. Continue to use this approach where the data has logic\n    around the change, but for the common situation where data is changed\n    at the end of the logic, use *riot.update!*.\n\n      (using [riot]\n        ...\n        (ref async-set-titles (lambda [title footer]\n          (riot.update! tag {title footer})\n        ))\n      )\n  ###\n  (ref update! (lambda [tag changes]\n    (tag.update! changes)\n    (tag.update) ## repaint\n  ))\n\n  ### spec: riot >> Tag support\n    Riot uses _this_ as context for codes within a tag. Also, when errors are\n    found it throws excepts that are difficult to track. Lispz provides help\n    with a riot-tag macro which invokes _using_,  provides a _tag_ reference\n    and wraps the code in a _try/catch_ to provide improved error reporting.\n\n      @TODO example\n  ###\n  (add-execution-context-logger \"riot\" (lambda [context error-args]\n    (return (+ \"for <\" context.node \"/>\"))\n  ))\n  (macro riot-tag [*body]\n    (ref tag (stateful.morph! this))\n    (execution-context {context: \"riot\" node: tag.root.nodeName tag}\n      *body\n    )\n  )\n  ## modules must be on mount or mounting will happen before trigger is set\n  (macro mount-tag-using [modules *body] (tag.on \"mount\" (=> (using modules\n    (execution-context {context: \"riot\" node: tag.root.nodeName tag}\n      *body\n    )\n  ))))\n\n  ### spec: async >> Events\n    Events follow [the observer pattern](https://en.wikipedia.org/wiki/Observer_pattern). Lispz provides access to the light-weight version in Riot. If you use Riot for UI components, the custom tags are always observers. You don't need to use riot to make use of events. You can either create an observable or make any object in the system observable.\n\n        (using [riot]\n          (ref observable-1 (riot.observable))\n          (ref element (get-my-element))\n          (riot.observable element)\n        )\n\n    Once that is out of the way, tell the observable what to do if it receives an event either once or every time.\n\n        (observable-1.on \"event-name\" (lambda [params...] what to do...))\n        (element.one \"focus\" (lambda [contents] (element.set contents)))\n\n    One observable can have many listeners for the same or different events. Use 'trigger' to wake an observable.\n\n        (observable-1.trigger \"event-name\" param1 param2)\n\n    Finally there needs to be a way to stop listening.\n\n        (observable-1.off \"event-name\" event-function-reference) ## stops one listener\n        (observable-1.off \"event-name\") ## stops all listeners to an event\n        (observable-1.off \"*\")          ## stops all listeners to all events for observable\n\n    ## Benefits\n    1. Decouples the code to whatever extent is necessary.\n    2. Associates code and data (such as the DOM).\n    3. Allows multiple invocations\n\n    ## Disadvantages\n    1. Too convoluted to use as an easy replacement for callbacks\n    2. One-way communication\n    3. No way of knowing if event was processed as expected.\n  ###\n\n  (ref loaded (net.script \"ext/riot.js\" (lambda (return window.riot))))\n  (promise.failed loaded (export {build}))\n  (when loaded (using [compilers]\n    (stateful.morph! riot.parsers.js)\n    (add-execution-context-logger \"riot.compile\" (lambda [context error-args]\n      (return (+ context.url \" -- source: \" context.source))\n    ))\n    (riot.parsers.js.update! {lispz:\n      (lambda [source options url]\n        (execution-context { context: \"riot.compile\" url options source }\n          (compilers.lispz.compile source \"riot-tags\")\n        )\n      )\n    })\n    (ref riot-elements (slice (document.getElementsByClassName \"riot\")))\n    (ref load-all (promise.all (riot-elements.map (lambda [element]\n      (ref name (element.tagName.toLowerCase))\n      (return (load name (element.getAttribute \"uri\")))\n    ))))\n    (when load-all\n      (riot.mount \"*\")\n      (export {build compile load mount inject update! child-tags tag-by-name})\n    )\n  ))\n)\n"

lispz_modules['doc/sicp']="(define \"Building Abstractions with Procedures\" =>\n  (define \"1.1  The Elements of Programming\" =>\n    (it \"1.1.1  Expressions\" =>\n      ((expect 486).toBe 486)\n      ((expect (+ 137 349)).toBe 486)\n      ((expect (- 1000 334)).toBe 666)\n      ((expect (* 5 99)).toBe 495)\n      ((expect (+ 2.7 10).toBe 12.7))\n\n      ((expect (+ 21 35 12 7)).toBe 75)\n      ((expect (* 25 4 12).toBe 1200)\n\n      ((expect (+ (* 3 5) (- 10 6))).toBe 19)\n      ((expect (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))).toBe 57)\n      ((expect\n        (+ (* 3\n            (+ (* 2 4)\n               (+ 3 5)))\n         (+ (- 10 7)\n            6))\n      ).toBe 57)\n    )\n    (it \"1.1.2  Naming and the Environment\" =>\n      (ref size 2) ## scheme uses define instead of ref\n      ((expect size).toBe 2)\n\n      (ref pi 3.14159) (ref radius 10) ## lispz allows more than one\n      ((expect (* pi (* radius radius))).toBe 314.159)\n      (ref circumference (* 2 pi radius))\n      ((expect circumference).toBe 62.8318)\n    )\n    (it \"1.1.4  Compound Procedures\" =>\n      ## In Scheme it is (define (square x) (* x x))\n      (ref square (lambda [x] (return (* x x))))\n\n      ((expect (square 21)).toBe 441)\n      ((expect (square (+ 2 5))).toBe 49)\n      ((expect (square (square 3))).toBe 81)\n\n      ## return values are not implicit in Lispz\n      (ref sum-of-squares (lambda [x y]\n        (return (+ (square x) (square y)))\n      ))\n      ((expect (sum-of-squares 3 4)).toBe 25)\n\n      ## Note the short-form (=> @) === (lambda [@] @)\n      (ref f (=> (return (sum-of-squares (+ @ 1) (* @ 2)))))\n      ((expect (f 5)).toBe 136)\n    )\n    (it \"1.1.6  Conditional Expressions and Predicates\" =>\n      (ref abs (lambda [x]\n        (cond\n          (< x 0) (- x)\n          (else)  x\n        )\n      ))\n\n      ((expect (abs(-33))).toBe 33)\n      ((expect (abs(22))).toBe 22)\n      ((expect (abs(0))).toBe 0)\n\n      (ref x 7)\n      (expect (and (> x 5) (< x 10)).toBeTruthy)\n      (ref x 111)\n      (expect (and (> x 5) (< x 10)).toBeFalsy)\n    )\n    (it \"1.1.7 Newton's Square Root\" =>\n      (ref sqrt-iter [guess x]\n        (cond\n          (good-enough? guess x)  guess\n          (else)  (sqrt-iter (improve guess x) x)\n        )\n      )\n      (ref improve [guess x]\n        (average guess (/ x guess))\n      )\n      (ref average [x y] (/ (+ x y) 2))\n\n      (ref good-enough? [guess x]\n        (< (abs (- (square guess) x) 0.001))\n      )\n      (ref sqrt [x] (sqrt-iter 1.0 x))\n\n      (expect ((sqrt 9).toBeCloseTo 3))\n      (expect ((sqrt (+ 100 37)).toBeCloseTo 11.7))\n      (expect (+ (sqrt 2) (sqrt 3)).toBeCloseTo 1.774)\n      (expect (square (sqrt 1000)).toBeCloseTo(1000))\n    )\n  )\n  (define \"1.2 Procedures and Processes They Generate\" =>\n    (it \"1.2.1 Linear Recursion and Iteration\" =>\n      (ref factorial (lambda [n]\n        (cond (= n 1) 1\n        (else) (* n (factorial (- n 1))))\n      ))\n    )\n  )\n)\n"

lispz_modules['dom']="(using [dict message]\n  (ref append! (lambda [parent element]\n    (ref selector (document.querySelector parent))\n    (selector.appendChild element)\n  ))\n\n  ### spec: DOM >> Replace inner html\n  Given an element, replace the contents with the html provided as a string.\n  ###\n (ref inner-html! (lambda [el html] (#set! el \"innerHTML\" html)))\n\n  ### spec: DOM >> Select Elements\n  This is a shortcut for element.querySelectorAll. It copies the\n  results into an Array of elements for further processing.\n  ###\n  (ref select (lambda [el selector]\n    (return (slice (el.querySelectorAll selector)))\n  ))\n\n  (ref style! (lambda [el styles]\n    (dict.for-each styles(lambda [name value]\n      (#set! el.style name value))\n    ))\n  )\n\n  (ref element (lambda [tag-name attributes]\n    (ref elem (document.createElement tag-name))\n    (dict.for-each (or attributes {}) (lambda [k v] (elem.setAttribute k v)))\n    (return elem)\n  ))\n\n  (ref event-throttle (lambda [element event action]\n    (ref add null)\n    (ref listener (lambda [event]\n      (element.removeEventListener event listener)\n      (delay 66 add)\n      (action event)\n    ))\n    (ref add (lambda [] (element.addEventListener event listener)))\n  ))\n\n  ### spec: DOM >> Forms >> Scraping\n    Given a parent element, return a dictionary\n    of input elements.\n  ###\n  (ref scrape-form (lambda [parent]\n    (ref form (first (select parent \"form\")))\n    form.elements\n  ))\n\n  ### spec: async >> Messaging >> Sources >> (dom.message)\n    Start a message stream from different sources. All curried\n    to create convenient functions.\n\n        (dom.message \"click\" \"my-message-address\" document.body)\n\n    will send messages to address _dom-click/my-message-name/_. For\n    convenience the method returns the full address for mapping and filtering.\n\n    We cache dom event listeners against the address being posted to. that\n    way the dom will not send the message multiple times if the source is\n    reinvoked.\n  ###\n  (ref dom-events (stateful))\n  (ref post-dom-event> (lambda [address]\n    (ref send-to-address (lambda [pkt] (message.send address pkt)))\n    (stateful.cache dom-events (=> send-to-address) address)\n  ))\n  ### ref: (dom.message event-name message-name element)\n    e.g. (ref address (dom.message \"click\" \"monitor\" document.body))\n  ###\n  (ref dom-message (lambda [event-name address-base element]\n    (ref address (message.combine-address (+ \"dom-\" event-name) address-base))\n    (cond (not (get dom-events address))\n      (element.addEventListener event-name (post-dom-event> address))\n    )\n    address\n  ))\n\n  ### ref: (dom.click message-name element)\n    e.g. (dom.click \"monitor\" document.body)\n    messages sent to returned address (**dom-click/monitor**)\n  ###\n  (ref click (lambda [address-base element]\n    (dom-message \"click\" address-base element)\n  ))\n\n  (export {\n    append! element event-throttle style! inner-html!\n    select scrape-form message: dom-message click\n  })\n)\n"

lispz_modules['events']="(ref throttle (lambda [limit callback]\n  (ref context (stateful))\n  (return (=>\n    (cond (not context.wait)\n      (callback)\n      (context.update! {wait: true})\n      (delay limit (context.update! {wait: false}))\n    )\n  ))\n))\n\n(ref delay (lambda [limit callback]\n  (ref context (stateful))\n  (return (=>\n    (clearTimeout context.timeout)\n    (context.update! { timeout: (delay limit (callback)) })\n  ))\n))\n\n(export {throttle delay})\n"

lispz_modules['firebase']="### spec: Libraries >> FireBase\nFirebase can power your app's backend, including data storage, user authentication, static hosting, and more. Focus on creating extraordinary user experiences. We'll take care of the rest.\n\nhttps://www.firebase.com/\n###\n(using  [net]\n  (ref databases (stateful.morph! (JSON.parse (or (localStorage.getItem \"firebases\") \"{}\"))))\n  (ref database-uri (pull databases))\n\n  (ref register (lambda [key uri]\n    (databases.update! key uri)\n    (localStorage.setItem \"firebases\" (JSON.stringify databases))\n  ))\n\n  (ref encode (lambda [before]\n    (ref uri (before.replace '/\\./g' \":\"))\n    (ref uri (uri.replace    '/#/g'  \"_hash_\"))\n    (ref uri (uri.replace    '/\\$/g' \"_dollar_\"))\n    (return uri)\n  ))\n\n  (ref attach (lambda [collection db]\n    (ref uri (database-uri (or db \"default\")))\n    (cond uri (new Firebase (+ uri \"/\" (encode collection))))\n  ))\n\n  (ref loaded (net.script \"https://cdn.firebase.com/js/client/2.2.9/firebase.js\"\n    (lambda (return window.Firebase))\n  ))\n  (when  loaded (export {register attach databases}))\n  ## (promise.failed loaded (export {}))\n)\n"

lispz_modules['firepad']="### spec: Libraries >> FirePad\nCollaborative Text Editor Powered by Firebase.\n\nhttps://github.com/firebase/firepad\n###\n(using  [net github]\n  (ref build (promise [target-repo]\n    (github.grunt target-repo \"firebase/firepad\" [grunt data]\n      (grunt.build {\n        target: \"firepad.js\"\n        pre:   data.concat.firepadjs.options.banner\n        post:  data.concat.firepadjs.options.footer\n        files: data.concat.firepadjs.src\n      } (lambda []\n        (grunt.copy data.copy.toBuild.files built=>)\n      ))\n    )\n  ))\n\n  (lispz.css \"ext/firepad.css\")\n  (ref loaded (net.script \"ext/firepad.js\" (lambda [] (return window.FirePad))))\n  (when loaded (export {build}))\n)\n"

lispz_modules['fp']="(using [list]\n  ### spec: Functional Programming >> curry\n  ###\n  (global curry (lambda [func]\n    (ref curried (=>\n      (ref args (*arguments 0))\n      (cond (>= args.length func.length)\n        (func.apply func args)  ## all done, run it\n      (else)\n        (=> ## otherwise return a partial function\n          (curried.apply this (args.concat (*arguments 0)))\n        )\n      )\n    ))\n  ))\n  (macro curry [params *body] (lispz.globals.curry (lambda params *body)))\n\n  ### ref: ((compose func1, func2 ...) seed) -- runs left to right\n    e.g. ((compose (=> (+ @ 1)) (=> (+ @ 2))) 3) ==> 6\n  ###\n  (global compose (=>\n    (ref funcs (list.flatten (*arguments 0)))\n    (=>\n      (funcs.reduce (lambda [previous current]\n        [[(current.apply this previous)]]\n      ) (*arguments 0))\n    )\n  ))\n\n  ### ref: (cascade func1, func2 ...)\n    e.g. (cascade (=> 1) (=> (+ @ 1)) (=> (+ @ 2))) ==> 4\n  ###\n  (global cascade (=> ((lispz.globals.compose arguments) null)))\n\n  ### spec: Functional Programming >> flip\n    Flip calling order of 2 parameters\n  ###\n  (global flip (curry [fn] (curry [a b] (fn b a))))\n\n  ### spec: basic >> Retrieval - can be used for objects and arrays\n    Retrieve elements by index for arrays and property for objects.\n\n        (get 1 [3,4,5])\n        ## is 4 the same as\n        (ref second (get 1))\n        (second [3,4,5])\n\n    Included are curries for _first_, _second_ and _third_. For objects, use\n    _in_ to clarify order\n\n        (get \"b\" in {a: 1 b: 2 c: 3})\n\n    or use _pull_ as a curry\n\n        (ref commands {a: 1 b: 2 c: 3})\n        (ref command (pull commands))\n        (command \"b\")\n  ###\n  (global dot    (curry [index array] (#join '' '(_res_=' array '[' index '])')))\n  (global pull   (flip lispz.globals.dot))\n  (global first  (dot 0))\n  (global second (dot 1))\n  (global third  (dot 2))\n  ### spec: Functional Programming >> map\n    Works on functors.\n  ###\n  (global map (lambda [item action] (item.map action)))\n  ### spec: Functional Programming >> filter\n    Works on functors.\n  ###\n  (global filter (lambda [item action] (item.filter action)))\n  ### spec: Functional Programming >> map and filter\n    (map-and-filter items (=> items.end))\n  ###\n  (global map-and-filter (compose lispz.globals.filter lispz.globals.map))\n\n  ### ref: (recurse function)\n      e.g. (ref sum (recursion [x y]\n             (cond (> y 0) (sum (+ x 1) (- x 1)) (else) x)\n           ))\n  ###\n  (global #recursion (lambda [context func]\n    (lambda\n        (ref args (*arguments))\n        (cond context.queue\n          (context.queue.push args)\n        (else)  (do\n          (context.update! { queue: [[args]]})\n          (#join '' 'while(' (ref next-args (context.queue.shift)) '){'\n            (context.update! { result: (func.apply null next-args)})\n          '}'))\n        )\n        context.result\n      )\n  ))\n  (macro recursion [?params *body]\n    (#recursion (stateful) (lambda ?params *body))\n  )\n\n  (export [])\n)\n"

lispz_modules['github']="### https://developer.github.com/v3/ ###\n### spec: Support\n  (using [github]\n    (ref delete-file> (lambda [path]\n      (ref repo (github.repo> \"paulmarrington/lispz\"))\n      (when (github.contents> repo \"master\" \"README.md\") [contents]\n        (github.delete> repo \"master\" contents.sha \"deleted\")\n      )\n    ))\n    (ref get-sha> (lambda [path]\n      (ref repo (github.repo> \"paulmarrington/lispz\"))\n      (when (github.contents> repo \"master\" path) @.sha)\n    ))\n    (ref create-file> (lambda [path]\n      (ref repo (github.repo> \"paulmarrington/lispz\"))\n      (when (github.create> repo \"master\" path \"Hi\" \"created\") @ ))\n    ))\n  )\n###\n(using [net dict dom]\n\n  ### spec: Retrieve repository details\n    (it \"will include the full name of the repo\" (lambda [done]\n      (using [github]\n        (when (github.repo> \"paulmarrington/lispz\") [repo]\n        	((expect repo.full_name).toEqual \"paulmarrington/lispz\")\n          (done)\n        )\n      )\n    ))\n  ###\n  ### ref: (github.repo> project) ## log in form displayed if necessary\n    e.g. (when (github.repo> \"paulmarrington/lispz\") [repo] ...)\n    https://developer.github.com/v3/repos/contents/#get-contents\n  ###\n  (ref repo> (lambda [name] (get> (+ \"repos/\" name) {})))\n\n  ### spec: List repositories for a user\n    (it \"will include the full name of the repo\" (lambda [done]\n      (using [github]\n        (when (github.repos> \"paulmarrington\") [repos]\n        	((expect repos.length).toBeGreaterThan 7)\n          (done)\n        )\n      )\n    ))\n  ###\n  ### ref: (github.repos> organisation)\n    e.g. (when (github.repos> \"paulmarrington\") [repos] ...)\n    https://developer.github.com/v3/repos/#list-user-repositories\n  ###\n  (ref repos> (lambda [owner]\n    (get> (cond owner (+ \"users/\" owner \"/repos\") (else) \"user/repos\") {\n      affiliation: \"owner,collaborator\" sort: \"full-name\"\n    })\n  ))\n\n  ### spec: Read contents given a branch and path\n    (it \"can be read as base64\" (lambda [done]\n      (using [github]\n        (ref (github.repo> \"paulmarrington/lispz\"))\n        (when (github.contents> repo \"master\" \"README.md\") [contents]\n        	((expect contents.encoding).toEqual \"base64\")\n          (done)\n        )\n      )\n    ))\n  ###\n  ### ref: (github.contents> <repo> branch path) ## info on dir or file\n    e.g. (when (github.contents> repo \"master\" \"/lib\" }))\n    https://developer.github.com/v3/repos/contents/#get-contents\n  ###\n  (ref contents> (lambda [repo branch path]\n    (when repo\n      (get> (+ \"repos/\" @.full_name \"/contents/\" path) { ref: branch })\n    )\n  ))\n\n  ### spec: Read contents given SHA\n    (it \"can be read as base64\" (lambda [done]\n      (using [github]\n        (ref repo (github.repo> \"paulmarrington/lispz\"))\n        (when (github.blob> repo \"master\" \"README.md\") [blob]\n        	((expect blob.encoding).toEqual \"base64\")\n          (done)\n        )\n      )\n    ))\n  ###\n  ### ref: (github.blob> <repo> sha)\n    e.g. (when (github.blob> repo tree[path].sha) [blob] blob.contents)\n    https://developer.github.com/v3/git/blobs/#get-a-blob\n  ###\n  (ref blob> (lambda [repo sha]\n    (when repo (get> (+ \"repos/\" @.full_name \"/git/blobs/\" sha)))\n  ))\n\n  ### spec: Download a file from the repository\n    (it \"can be read in text form\" (lambda [done]\n      (using [github]\n        (ref repo (github.repo> \"paulmarrington/lispz\"))\n        (when (github.read> repo \"master\" \"README.md\") [contents]\n        	((expect contents).toEqual \"base64\")\n          (done)\n        )\n      )\n    ))\n  ###\n  ### ref: (github.read> <repo> branch path)\n    e.g. (when (github.read> repo \"master\" \"README.md\") [contents] ...)\n  ###\n  (ref read> (lambda [repo branch path] (when repo\n    (ref base \"https://raw.githubusercontent.com\")\n    (ref url (+ base \"/\" @.full_name \"/\" branch \"/\" path))\n    (net.http-get url)\n  )))\n\n  ### spec: Create a new entry\n    (it \"can create a new entry\" (lambda [done]\n      (using [github]\n        (ref repo (github.repo> \"paulmarrington/lispz\"))\n        (when (github.create> repo \"master\" \"test/tmp.txt\" \"Hi\" \"msg\") [result]\n        	((expect result.message).toEqual \"msg\")\n          (done)\n        )\n        (when-rejected [err] (fail \"Can't create -\" err) (done))\n      )\n    ))\n  ###\n  ### ref: (github.create> <repo> branch path contents commit-message)\n    (when (github.create> repo \"master\" \"test/tmp.txt\" \"Hi\" \"msg\") [result] ...)\n    https://developer.github.com/v3/repos/contents/#create-a-file\n  ###\n  (ref create> (lambda [repo branch path contents message] (when repo\n    (ref url (+ \"repos/\" @.full_name \"/contents/\" path))\n    (ref options { branch message content: (net.base64 contents) })\n    (request> \"PUT\" url options)\n  )))\n\n  ### spec: Update an entry\n    (it \"can update an entry\" (lambda [done]\n      (using [github]\n        (when (create-file> \"test/tmp.txt\" \"created\")\n        (when (get-sha> \"test/tmp.txt\") [sha]\n        (ref repo (github.repo> \"paulmarrington/lispz\")\n        (when (github.update> repo \"master\"\n        \"test/tmp.txt\" sha \"2nd\" \"changed\") [results]\n          ((expect results.message).toEqual \"changed\")\n        ))))\n        (when-rejected [err] (fail \"Can't update -\" err) (done))\n      )\n    ))\n  ###\n  ### ref: (github.update> <repo> branch path sha contents commit-message)\n    (when (github.update> repo \"master\" \"test/tmp.txt\" sha \"Hi\" \"msg\") [result] ...)\n    https://developer.github.com/v3/repos/contents/#update-a-file\n  ###\n  (ref update> (lambda [repo branch path sha contents message] (when repo\n    (ref url (+ \"repos/\" @.full_name \"/contents/\" path))\n    (ref options { branch message sha content: (net.base64 contents) })\n    (request> \"PUT\" url options)\n  )))\n\n  ### spec: Delete an entry\n    (it \"can delete an entry\" (lambda [done]\n      (using [github]\n        (when (create-file> \"test/tmp.txt\" \"created\")\n        (when (get-sha> \"test/tmp.txt\") [sha]\n        (ref repo (github.repo> \"paulmarrington/lispz\")\n        (when (github.delete> repo \"master\" \"test/tmp.txt\" sha \"no more\")\n          ((expect results.commit.message).toEqual \"no more\")\n        ))))\n        (when-rejected [err] (fail \"Can't delete -\" err) (done))\n      )\n    ))\n  ###\n  ### ref: (github.delete> <repo> branch path sha commit-message)\n    (when (github.delete> repo \"master\" \"test/tmp.txt\" sha \"msg\") [result] ...)\n    https://developer.github.com/v3/repos/contents/#delete-a-file\n  ###\n  (ref delete> (lambda [repo branch path sha message] (when repo\n    (ref url (+ \"repos/\" @.full_name \"/contents/\" path))\n    (ref options { branch message sha })\n    (request> \"DELETE\" url options)\n  )))\n\n  ### spec: List contents of a repository\n    (it \"can retrieve a tree object\" (lambda [done]\n      (using [github]\n        (ref repo (github.repo> \"paulmarrington/lispz\")\n        (when (github.tree> repo \"master\") [tree]\n        	((expect tree.tree.length).toBeGreaterThan 100)\n          (done)\n        ))\n      )\n    ))\n  ###\n  ### ref: (github.tree> <repo> branch) ## recursive info tree\n    e.g. (when (github.tree> repo \"master\" }))\n    https://developer.github.com/v3/git/trees/#get-a-tree-recursively\n  ###\n  (ref tree> (lambda [repo branch] (when repo [repo]\n    (when (branch> repo branch) [branch]\n    (get>\n      (+ \"repos/\" repo.full_name \"/git/trees/\" branch.commit.sha)\n      { recursive: 1 }\n    ))\n  )))\n\n  ### spec: Retrieve branch\n    (it \"can retrieve branch details\" (lambda [done]\n      (using [github]\n        (ref repo (github.repo> \"paulmarrington/lispz\")\n        (when (github.branch> repo \"master\") [branch]\n        	((expect branch.name).toequal \"master\")\n          (done)\n        ))\n      )\n    ))\n  ###\n  ### ref: (github.branch> <repo> [branch]) ## branch defaults to master\n    e.g. (when (github.branch repo) [branch] ...)\n    https://developer.github.com/v3/repos/#get-branch\n  ###\n  (ref branch> (lambda [repo branch] (when repo [data]\n    (get> (+ \"repos/\" data.full_name \"/branches/\" (or branch \"master\")))\n  )))\n\n  ### ref: (github.session>)\n    Start a GitHub session. Shows modal dialog if user-name and password\n    are not in browser storage.\n  ###\n  (ref session> (=>\n    (ref auth (or\n      (sessionStorage.getItem \"ghcontext\")\n      (localStorage.getItem \"ghcontext\")\n    ))\n    (cond\n      auth    (promised { auth-header: auth })\n      (else)  (ask-user-to-login>)\n    )\n  ))\n\n  (ref ask-user-to-login> (promise (using [bootstrap]\n    (when (bootstrap.modal> \"github/github-login\" {}) [r]\n      (cond (is r.login.value \"true\") (do\n        (ref joined (+ r.username.value \":\" r.password.value))\n        (ref auth (+ \"Basic \" (btoa joined)))\n        (save-user auth r.remember.checked)\n        (resolve-promise { auth-header: auth })\n      ) (else)\n        (reject-promise { error: true reason: \"User abort\" })\n      )\n    )\n  )))\n  (ref save-user (lambda [auth remember]\n    (cond (is remember)\n      (localStorage.setItem \"ghcontext\" auth)\n    (else) (do ## user wants amnesia\n      (localStorage.removeItem \"ghcontext\")\n      (sessionStorage.setItem \"ghcontext\" auth)\n    ))\n  ))\n\n  (ref request> (lambda [type url options]\n    (ref send-request (lambda [session]\n      (ref headers {\n        Accept:           \"application/vnd.github.v3+json\"\n        Authorization:    session.auth-header\n        'Content-Type':   \"application/json;charset=UTF-8\"\n      })\n      (net.http-request> type\n        (+ \"https://api.github.com/\" url) headers\n        (JSON.stringify options)\n      )\n    ))\n\n    (when session> (when (send-request @) [response]\n      (JSON.parse response)\n    ))\n  ))\n\n  (ref get> (lambda [url options]\n    (request> \"GET\" (+ url (net.dict-to-query options)) {})\n  ))\n\n  ### ref: (github.cdn-uri project hash filepath)\n    e.g. (ref uri (github.cdn-uri \"atogov/RAM\" \"develop\" \"tests/pasckages.json\"))\n  ###\n  (ref cdn-uri (lambda [project hash filepath]\n    (return (+ \"https://cdn.rawgit.com/\" project \"/\" hash \"/\" filepath))\n  ))\n\n  ### ref: (ref fs (once github.fs repo branch)) ## entries> read> write>\n    e.g. (when fs (when (@.read> \"README.md\") [md] ...))\n  ###\n  (ref fs (lambda [name branch]\n    (ref repo  (once (repo> name)))\n    (ref entries> (once (when (tree> (repo) fs.branch) [tree]\n      (dict.from-list tree.tree \"path\")\n    )))\n    (ref read> (lambda [path] (github.read> (repo) fs.branch path)))\n    (ref write> (lambda [path contents message]\n      (when entries>\n        (cond (ref meta (get @ path))\n          (github.update> (repo) fs.branch path meta.sha contents message)\n        (else)\n          (github.create> (repo) fs.branch path contents message)\n        )\n      )\n    ))\n    (ref fs { name entries> read> write> branch: (or branch \"master\")})\n  ))\n\n  (ref github {\n    repo> repos> cdn-uri contents> tree> branch> blob> read>\n    create> update> delete> fs\n  })\n  (export github)\n)\n"

lispz_modules['grunt']="(using  [github compilers]\n\n  (ref grunt-build (promise [meta]\n    (ref js (stateful [(or meta.pre \"\")]))\n    (ref read-all (promise.all (meta.files.map (promise\n      (when (github.fs.read source-repo path) [data]\n        (js.push! data) (resolve-promise)\n      )\n    ))))\n    (when read-all\n      (js.push! (or meta.post \"\"))\n      (ref contents (js.join \"\\n\"))\n      (when (write target-repo (+ \"ext/\" meta.target) contents comment)\n        (resolve-promise)\n      )\n    )\n  ))\n  (ref grunt-copy (promise [files]\n    (ref copy-all (promise.all (files.map (promise [item]\n      (ref path (or item.src item))\n      (when (github.fs.read source-repo path) [contents]\n        (ref path (+ \"ext/\" (last (path.split \"/\"))))\n        (when (write target-repo path contents comment)  (resolve-promise))\n      )\n    ))))\n  ))\n  (ref grunt (promise [target-repo source-project]\n    (ref source-repo (github.fs.repo target-repo source-project))\n    (ref comment (+ \"from \" source-project))\n    (ref sources [[\n      {repo: source-project files: [[\n        {include: '/^Gruntfile.js$/' single-level: true}\n      ]]}\n    ]])\n    (when (retriever target-repo sources github.fs) [store]\n      (ref grunt-config ((Function\n        (+ \"var module={};\" (last store.js) \"return module.exports\"))))\n      (grunt-config {\n        loadNpmTasks: (lambda) registerTask: (lambda)\n        initConfig: (lambda [config-data]\n          (ref grunt-processor {\n            build: grunt-build\n            copy:  grunt-copy\n          })\n          (when (update target-repo)\n            (resolve-promise grunt-processor config-data)\n          )\n        )\n      })\n    )\n  ))\n\n  (export { grunt })\n)\n"

lispz_modules['index']="### spec: Introduction ###\n### spec: basics -- The Basics ###\n### spec: lists -- List Processing ###\n### spec: Macros ###\n### spec: Modules ###\n### spec: async -- Asynchronous Programming ###\n### spec: riot -- UI Components with RIOT ###\n### spec: bootstrap -- Bootstrap Integration ###\n### spec: codemirror -- CodeMirror Integration ###\n### spec: developer -- Developer Tools ###\n### spec: Deployment ###\n### spec:  ###\n\n### spec: Introduction\n# Why another *&^% language?\n**For Fun:**\nIt is fun to create something new - even when you are following paths well trodden by others for decades.\nBy making your own decisions and learning from them you get a better understanding of the how and why of\nother languages.\n\n**Extensibility:**\nFew languages macros integrated in the language - where macros are expressed in the language itself.\nThere is no difference between built-ins, libraries and code created by the end-user.\n\n**Simplicity:**\nMany languages and frameworks are overloaded with features - generating a huge learning curve.\n\n# Overcoming the fear of change\nLispz has different expression ordering, lots of parentheses and function programming overtones.\nIf you have a fear of change and, like me, had decades of OO and Imperative software development\nthen Lispz looks strange, behaves strangely and requires a diffent way of thinking.\n\nAnd yet, Lispz is only a thin veneer over JavaScript.\n\n    Javascript: console.log(\"message:\", msg)\n    Lispz:      (console.log \"message:\" msg)\n    \nIf you move the parenthenis pairs around and replace brace with parenthesis then the\nsurface similarities become more obvious.\n\nThe first major difference is not what has been added, but what has been taken away.\nLisp(z) has a lot less syntax. Only\n\n    (fn params)\n    [list]\n    {dict}\n    \nform the core syntax. Everything else is either a function or a macro.\nWe won't talk more about macros yet - in case parenoia sets in.\n\n# The benefits of lisp\nHaving only parenthesis, bracket or brace to deal with reduces ambiguity - when used\nwith appropriate white-space. In many cases the functional style can be clearer:\n\n    (or value default1 default2 12)\n    (+ a b 12)\n\nalthough not always\n\n    (/ (* value percent) 100)\n  \nWhile our practiced eye finds this harder to understand than \"a * percent / 100\" it\nis easier to decipher. Take the 'standard' syntax. Are these the same:\n\n    value * percent / 100\n    (value * percent) / 100\n  \nYou win if you said 'no'. In most languages operator precedence is such that the first\nsample will do the divice before the multiply. With real numbers the change in order can\ncause a diffent result. For languages without auto-conversion, the first will return zero\n(assuming percent is less than 100). With auto-conversion and all integers, the first will\ncause two floating point operations while the second only one.\n\nBack to\n\n    (/ (* value percent) 100)\n  \nWith the understanding that everthing appears to be a function, it becomes easier to read\nand there are no ambiguities. The word 'appears' is intentional as Lispz expands binaries in-line,\nsuch that the code run is\n\n    ((value * percent) / 100)\n\n# Where functional programming comes in\nShhh! Don't tell the Haskellers. JavaScript is already a functional language in that it\nprovides functions as first-class operation, closures and bindings. There are other aspects\nthat it does not support - the major ones being immutability and static types. I think of\nJavaScript as a modern assember, making it the responsibility of the higher (:)\nlevel language to fill in the gaps.\n\nLispz is too lightweight to do anything about static types.\n\nImmutability is a moving target. For a functional language, this means if a function is\ncalled with the same parameters it will always return the same result. Another definition\nstates \"no side-effects\". A third suggest it means all data on the stack - meaning function\ncall parameters. In the extreme it means that there are no variables, only constants -\ndata once allocated never changes.\n\nLispz takes a pragmatic approach leaving it up to the developer. It keeps the JavaScript\nconcept of a 'var' - leaving it easy to change within the same function and accessible as\nan immutable variable to inner functions. Because immutability is such a hard task master\nin an imperative world (such as the dom), Lisp does incude a set! operator.\nUnlike assignment, set! is painful enough to remind the developer to limit it's use.\nPutting a bang after any exported function that includes mutability provides a good hint to\nrule-breaking. It is up to the developer to ensure than any function exported from a module\nhonours the immutability and repeatability rules - and to flag the method when this is not possible.\n###\n\n(export {}) ## in case it gets included in another module\n"

lispz_modules['jquery']="### Libraries >> jQuery\nNew Wave JavaScript\n\nhttps://github.com/jquery/jquery\n###\n(using [net cdnjs]\n  (ref build (lambda [target-repo]\n    (return (cdnjs.build target-repo \"jquery\" [[\n      {repo: \"jquery\" files: [[\n        {exclude: '/\\.map$|\\.min.js$/'}\n      ]]}\n    ]]))\n  ))\n  (ref loaded (net.script \"ext/jquery.js\" (lambda (return window.jQuery))))\n  (when  loaded (export {build}))\n  (promise.failed loaded (export {build}))\n)\n"

lispz_modules['js_beautify']="### spec: Libraries >> JS-Beautify\nBeautifier for JavaScript\n\nhttp://jsbeautifier.org/\nhttps://github.com/beautify-web/js-beautify\n###\n(using [net]\n  (ref build (lambda [target-repo built=>] (using [code-builder]\n    (return (code-builder target-repo \"js_beautify\" [[\n      {repo: \"beautify-web/js-beautify\" files: [[\n        {base: \"js/lib\" include: '/^beautify.js$/'}\n      ]]}\n    ]]))\n  )))\n  (ref loaded (net.script \"ext/js-beautify.js\" (lambda []\n    (return window.js_beautify))\n  ))\n  (ref beautify (stateful.morph! (lambda [js]\n    (ref no-refs (js.replace '/\\/\\*##\\d+##\\*\\//g' \"\"))\n    (ref no-semis (no-refs.replace '/(;(\\s*;)+)/g' \";\"))\n    (ref beautified (window.js_beautify no-semis))\n    (beautified.replace '/^\\s*\\/\\/#.*$/m' \"\")\n  )))\n  (beautify.update! { build })\n  (when loaded [] (export beautify))\n)\n"

lispz_modules['list']="### spec: lists >> flatten - Flattening Lists of Lists\n###\n(ref flatten (lambda [list]\n  (list.reduce (lambda [a b]\n    (ref bflat (cond (instance-of Array b) (flatten b) (else) b))\n    (return (a.concat bflat))\n  ) [[]])\n))\n\n### spec Lists >> squash\n  It is a common pattern to return a value or a list of more than one value is\n  expected.\n###\n(ref squash (=> (cond (is @.length 1) (get @ 1) (else) @)))\n\n### spec: lists >> for-each\n  This is a helper for the JavaScript [].forEach(). It has the advantage that\n  it behaves correctly if the item is not an array by running once for the entry\n  if it is not a falsy.\n###\n(ref for-each (lambda [list action]\n  (cond (not list)               null\n        (instance-of Array list) (list.forEach action)\n        (else)                   (action list)\n  )\n))\n\n### spec: List and dictionary manipulation ###\n(macro length [list] (#join '' list '.length'))\n(macro rest [list] (list .slice 1))\n(macro last [list] (first (list .slice -1)))\n(global slice (lambda [list from to]\n  (Array.prototype.slice.call list from to)\n))\n\n### spec: lists >> contains\n###\n(ref contains (lambda [substr str] (return (isnt -1 (str .indexOf substr)))))\n\n### ref: (list.sort my-list) ## return a new list with items sorted\n###\n(ref sort (lambda [list] ((slice list).sort)))\n\n### ref: (list.reverse my-list) ## return a new list with item order reversed\n###\n(ref reverse (lambda [list] ((slice list).reverse)))\n\n(export { flatten squash for-each contains reverse sort })\n"

lispz_modules['macros']="### spec: macros >> What is a Macro?\n\nThe term \"macro\" includes text substitution (e.g. ASM and C) and syntactic macros. Lisp has had the latter proposed 1963 or soon after. By working on the abstract syntax tree (AST), a macro has the full faculties and syntax of the language to effectively extend the language. Another way of looking at it is that lisp macros run lisp code during the compile to modify the resulting program. Yes, I know this is still not clear. Read https://en.wikipedia.org/wiki/Macro_%28computer_science%29 for a more informative perspective.\n\ncreates a new language element that only returns if the value is a truthy, as in\n\n    (ref result ....)\n    (return? result)\n    ## try something else\n\nThis example would also work with a text substitution macro system, but this one doesn't:\n\n    (macro closure [params *body] (#join '' '(lambda(' params '){' *body '})(' params ')'))\n\nThis generates the JavaScript output directly as #join is an immediate function called during the\nast to JavaScript phase.\n\n### spec: macros >> Defining a Macro\n\nA macro is defined by giving it a name, list of parameters and a body. In it's simplest form the parameters are substituted into the body at reference time. It is like a function expanded in-line.\n\nImmediate actions are required to modify the JavaScript output during the compile stage (ast to JavaScript).\n\n    (macro function [params *body] (#join '' '(lambda(' params '){' *body '})'))\n\nParameters that start with star must be the last in the list and encapsulate all the remaining parameters in the expansion. This is why function works:\n\n    (lambda [a b] (ref c (+ a b)) (return c))\n\n### spec: macros >> #join\nMany macros translate lispz directly to JavaScript by mixing pure JavaScript with macro parameters that can convert themselves to JavaScript. It is an immediate function - being one that runs during the compile phase. The first parameter is the text to be used between the segments. In this context it is usually empty. The first parameter along with the JavaScript are wrapped in single quotes so that they are left as-is in the JavaScript output.\n\n    (macro set! [name value] (#join '' name '=' value ';'))\n\n### spec: macros >> #pairs\nPairs is more rarely used. It takes a list and creates output based on pairs in that list. Hmmm, that is not very clear. Best use an example then.\n\n    (macro var (*list) (#join '' 'var ' (#pairs *list '=' ',') ';'))\n    (ref a 12  b \"hi\") ##js=> var a=12,b=\"hi\";\n\nPairs takes a list, the code within each pair and the string between pairs. In this example, = is between the two items in the pair and , is between pairs. If you need it clearer than that, try meditating on the two sample lines above - or don't use #pairs.\n\n### spec: macros >> immediate\n\nMacros allow you to change lispz by adding new build-in commands. By their nature, macros allow the use of lispz at compile time to generate the resulting lispz code. Most macros are to generate JavaScipt\n\n    (macro return [value] (#join '' 'return ' value '\\n'))\n\nDouble-check substitution macros. The one above must be a macro, but may could be easily converted into global functions\n\n    (macro empty? [list] (not list.length))\n    # is functionally the same as\n    (global empty? [list] (return (not list.length)))\n\nThe built-ins #join and #pairs are example of immediate functions - ones that operate during the compile phase. Lispz would not be complete if you could not also create immediate functions.\n\n    (immediate 'alert(\"Hi\")')\n\nWorks but has no point. I added immediate for language completeness. I have not yet found a use for it.\n\n    (global #join2 (lambda [sep parts]\n      (immediate (*arguments 1) '.map(lispz.ast_to_js).join(lispz.ast_to_js(sep)')\n    ))\n\n\n(export {})\n"

lispz_modules['markdown']="### spec: Libraries >> Showdown\nA Markdown to HTML converter written in JavaScript\n\nhttp://showdownjs.github.io/demo/\nhttps://github.com/showdownjs/showdown\n###\n(using [net cdnjs dict]\n  (ref build (lambda [target-repo]\n    (return (cdnjs.build target-repo \"showdown\" [[\n      {repo: \"showdown\" files: [[\n        {include: '/showdown.js$/'}\n      ]]}\n    ]]))\n  ))\n  (ref default-options {\n    ## (boolean) Omit the trailing newline in a code block.\n    omitExtraWLInCodeBlocks: false\n    ## (boolean) Disable the automatic generation of header ids.\n    noHeaderId: false\n    ## (string/boolean) Add a prefix to the generated header ids.\n    prefixHeaderId: false\n    ## (boolean) Enable support for setting image dimensions.\n    parseImgDimensions: false ## ![foo](foo.jpg =100x80) -- *, px, %, em\n    ## (integer) Set the header starting level.\n    headerLevelStart: 2\n    ## (boolean) Enable GFM autolink style.\n    simplifiedAutoLink: true\n    ## (boolean) Stop interpreting underscores in the middle of words\n    literalMidWordUnderscores: false\n    ## (boolean) Enable support for strikethrough syntax (~~strike~~)\n    strikethrough: true\n    ## (boolean) Enable support for tables syntax.\n    tables: true\n    ## (boolean) Adds an id property to table headers tags.\n    tablesHeaderId: true\n    ## (boolean) Enable support for GFM code block style.\n    ghCodeBlocks: true\n    ## (boolean) Enable support for GFM takslists.\n    tasklists: true\n    ## (boolean) Prevents weird effects in live previews due to incomplete input\n    smoothLivePreview: false\n  })\n\n  (ref compile (lambda [markdown options]\n    (ref options (dict.merge (or options {}) default-options))\n    (ref converter (new showdown.Converter options))\n    (ref html (converter.makeHtml markdown))\n    (return html)\n  ))\n\n  (ref loaded (net.script \"ext/showdown.js\" (lambda (return window.showdown))))\n\n  (when  loaded (export {build compile}))\n  (promise.failed loaded (export {build}))\n)\n"

lispz_modules['message']="### spec: async >> Messaging\n###\n(using [list dict]\n  (ref exchange  (stateful))\n  (ref observers (stateful.cache exchange (=> (stateful []))))\n\n  ### spec: async >> Messaging >> (clear)\n    Clear all observers from a message box.\n  ###\n  (ref clear (lambda [matcher]\n    (cond (instance-of RegExp matcher)  (clear-by-regexp matcher)\n          (else)                        (clear-by-name   matcher)\n    )\n  ))\n  (ref clear-by-regexp (lambda [matcher]\n    (ref matches (dict.filter exchange (=> (matcher.test @))))\n    (list.for-each matches (=> (clear-by-name @)))\n  ))\n  (ref clear-by-name (lambda [name]\n    (exchange.update! name (stateful []))\n  ))\n\n  ### spec: async >> Messaging >> Sources >> (request>)\n    Send a message directly to an address so that it is picked up by\n    all observers. Call returns a promise\n    that is fulfulled when all listeners have responded. The promise\n    returns an array of results for each listener.\n\n        (ref requested (message.request> \"examples/my-address\"\n          { msg: \"whatsit\" read-now: true }\n        ))\n        (when requested [results context] ...)\n\n    For in-process addresses, the observers are expected to be well behaved.\n    They should (yield) the CPU rather that take too much time.\n  ###\n  (ref request> (lambda [address packet]\n    (ref postman (lambda [obs] (promised (obs.action> packet obs))))\n    (promise.all ((observers address).map postman))\n  ))\n\n  ### spec: async >> Messaging >> Sources >> (send)\n    Send a message directly to an address so that it is picked up by\n    all observers. Unlike _request>_, _send_\n    does not expect the receivers to respond.\n  ###\n  (ref send (lambda [address packet]\n    (ref postman (lambda [obs] (yield (obs.action> packet obs))))\n    ((observers address).map postman)\n  ))\n\n  ### spec: async >> Messaging >> (ready>)\n    If a _post>_ can happen before a listener is set - and it is important\n    that the _post>_ is heard, wrap it in a _ready>_.\n  ###\n  (ref ready> (promise [address]\n    (ref ready-check (=>\n      (ref listeners = (observers address))\n      (cond listeners.length\n        (resolve-promise)\n      (else)\n        (delay 100 ready-check)\n      )\n    ))\n  ))\n\n  ### spec: async >> Messaging >> Sources >> (observe)\n    Observe the passage of a message. An action is called with the packet\n    and a reference to the observer object as stateful local context.\n    The action can return a promise and preferably not do anything too\n    time-costly in-process.\n  ###\n  (ref listen (lambda [address action>]\n    ((observers address).push! (stateful { action> }))\n  ))\n\n  ### spec: async >> Messaging >> Sources >> (dispatch)\n    Dispatch is a specialised version of observe where a number of actions\n    can be defined and messages built to dispatch to them.\n\n        (ref open  (=> ...))\n        (ref close (=> ...))\n        (message.dispatch \"my-component\" { open close })\n\n    Each action creates a separate message-box using the given address followed\n    by the action name. In this example, _my-component/open_ and _my-component/close_.\n  ###\n  (ref dispatch (lambda [address actions]\n    (dict.for-each actions (lambda [name action>]\n      (message.listen (+ address \"/\" name) action>)\n    ))\n  ))\n\n  ### spec: async >> Messaging >> Sources >> (combine-address)\n    Mapping and filtering messages are given source and target\n    addresses. If the target address starts with a / it is used\n    alone, otherwise the source and target addresses are concatenated.\n\n        (combine-address \"left\" \"right\")  ## left/right\n        (combine-address \"left\" \"/right\") ## right\n  ###\n  (ref combine-address (lambda [from to]\n    (cond\n      (is (first to) \"/\")   (slice to 1)\n      (else)                (+ from \"/\" to)\n    )\n  ))\n\n  ### ref: (from.update! {source: (lambda [address ...])})\n      e.g. (from.update! {callback: (lambda [address] ...)})\n      then use as (message.from.callback \"my-address\")\n  ###\n  (ref from (stateful {\n    promise: (lambda [address a-promise]\n      (when a-promise [packet] message.send (*arguments 0))\n    )\n  }))\n\n  ### spec: async >> Messaging >> Modifiers >> (map)\n    Map message streams to change the results\n        (ref @click (message.from.click \"my-message-address\" document.body))\n        (ref @mouse (message.map @click \"mouse\" (lambda [event]\n          {x: event.clientX  y: event.clientY}\n        )))\n        (message.listen @mouse (=> (console.log @.x @.y)))\n  ###\n  ### ref: (message.map from to mapper)\n    e.g. (message.map @click \"mouse\" (=> {x: @.clientX y: clientY}))\n    will send messages to (+ @click \"/mouse\") - use \"/to\" for abs address\n  ###\n  (ref message-map (lambda [from to mapper]\n    (ref address (combine-address from to))\n    (message.listen from (=> (message.send address (mapper @))))\n    address\n  ))\n\n  ### spec: async >> Messaging >> Modifiers >> (filter)\n    Map message streams to change the results\n        (ref @click (message.from.click \"my-message-address\" document.body))\n        (ref @mouse (message.map @click \"mouse\" (lambda [event]\n          {x: event.clientX  y: event.clientY}\n        )))\n        (ref @top-left (message.filter @mouse \"top-left\" (lambda [pos]\n          (< pos.x pos.y)\n        )))\n        (message.listen @top-left (=> (console.log @.x @.y)))\n  ###\n  ### ref: (message.filter from to filterer)\n    e.g. (message.filter @mouse \"top-left\" (=> (< @.x @.y)))\n    will send messages to (+ @mouse \"/top-left\") - use \"/to\" for abs address\n  ###\n  (ref message-filter (lambda [from to filterer]\n    (ref address (combine-address from to))\n    (message.listen from (=> (cond (filterer @) (message.send address @))))\n    address\n  ))\n\n  ### ref: (message.throttle address milliseconds)\n    e.g. (message.throttle @mouse 100) sends (+ @mouse \"/100ms\")\n    will only pass messages every 100ms or more apart to\n  ###\n  (ref throttle (lambda [from ms]\n    (ref address (+ from \"/\" ms \"ms\"))\n    (message.listen from (lambda [packet context]\n      (ref now (new Date))\n      (ref elapsed (- now (or context.last-message-time 0)))\n      (cond (> elapsed ms) (do\n        (context.update! { last-message-time: now })\n        (message.send address packet)\n      ))\n    ))\n    address\n  ))\n\n  ### spec: async >> Messaging >> Sources >> (trace)\n    Turning tracing on will display messages posted and received to\n    the browser console. Use a regular expression to reduce the number\n    of messages to a manageable amount. A parameter of false will turn\n    trace off again.\n  ###\n\n  (ref with-tracing (lambda [name action filterRE has-packet]\n    (lambda [address packet]\n      (cond (filterRE.test address)\n        (console.trace name \"\\t\" address (cond has-packet packet (else) \"\"))\n      )\n      (action address packet)\n    )\n  ))\n\n  (ref set-trace (lambda [filterRE]\n    (message.update! {\n      send:     (with-tracing \"SEND    \"  send      filterRE true)\n      request>: (with-tracing \"REQUEST \"  request>  filterRE true)\n      listen:   (with-tracing \"LISTEN  \"  listen    filterRE false)\n    })\n  ))\n\n  (ref trace (=>\n    (cond\n      (is @ false)    (message.update! { send request> listen })\n      (not @)         (set-trace '/.*/')\n      (else)          (set-trace @)\n    )\n  ))\n\n  (ref message (stateful {\n    send listen dispatch request> clear trace from ready>\n    map: message-map filter: message-filter combine-address\n    exchange throttle\n  }))\n  (lispz.update! {message})\n  (export message)\n)\n"

lispz_modules['net']="(using [list dom regex dict]\n  (ref script (promise.callback [uri check max-ms] (lispz.script uri (lambda []\n    (cond check (do\n      (ref initialised (wait-for check max-ms))\n      (when  initialised [] (callback))\n      (promise.failed initialised [] (debug (+ uri \"didn't load\")))\n    ) (else) (return (callback))\n    )\n  ))))\n\n  (ref css (lambda [uri]\n    (ref el (dom.element \"link\" {\n      type: \"text/css\" rel: \"stylesheet\" href: uri\n    }))\n    (dom.append! \"head\" el)\n  ))\n\n  (ref http-request> (promise.callback [type uri headers body]\n    (lispz.http_request uri type callback headers body)\n  ))\n\n  (ref http-get (promise.callback [uri headers]\n    (lispz.http_request uri \"GET\" callback headers)\n  ))\n\n  (ref json-request (promise [uri headers]\n    (when (http-get uri headers) [response]\n      (resolve-promise (JSON.parse response))\n    )\n  ))\n\n  ### spec: Network >> Is URL external\n  ###\n  (ref external? (lambda [url] (return (list.contains \"://\" url))))\n\n  ### spec: Network >> Retrieve the last element in a URL path\n  ###\n  (ref url-path (lambda [href]\n    (return (regex.substring href '/(.*\\/)[^\\/]*$/'))\n  ))\n\n  ### spec: Network >> Retrieve the last element in a URL path\n  ###\n  (ref url-actor (lambda [href]\n    (return (regex.substring href '/.*\\/([^\\/]*)(?:\\?.*)?$/'))\n  ))\n\n  ### ref: (net.dict-to-query data)\n    e.g. (net.dict-to-query { a: 1  b: 2 }) ## ==> \"?a=1&b=2\"\n  ###\n  (ref dict-to-query (=>\n    (ref kvp (dict.map (or @ {}) (lambda [k v]\n      (+ (encodeURIComponent k) \"=\" (encodeURIComponent v))\n    )))\n    (+ \"?\" (kvp.join \"&\"))\n  ))\n\n  ### ref: (ref encoded (base64 contents)) ## replaces >0xFF with space ###\n  (ref base64 lispz.base64)\n\n  ### ref: (ref uri (data-uri (base64 contents))) ###\n  (ref data-uri lispz.data_uri)\n\n  (export {\n    script css http-get json-request external? url-actor url-path\n    dict-to-query http-request> base64 data-uri\n  })\n)\n"

lispz_modules['paredit']="### codeeditor >> codemirror >> ParEdit\n###\n    (ref extraKeys {\n      ## paredit keys that defer if not in lisp code\n      'Backspace':        \"subpar_backward_delete\"\n      'Delete':           \"subpar_forward_delete\"\n      'Ctrl-D':           \"subpar_forward_delete\"\n\n      'Shift-9':          \"subpar_open_bracket\"\n      '[':                \"subpar_open_square_bracket\"\n      'Shift-[':          \"subpar_open_braces\"\n\n      'Shift-0':          \"subpar_close_bracket\"\n      ']':                \"subpar_close_square_bracket\"\n      'Shift-]':          \"subpar_close_braces\"\n\n      'Shift-\\'':          \"subpar_double_quote\"\n\n      'Ctrl-Alt-F':       \"subpar_forward\"\n      'Ctrl-Alt-B':       \"subpar_backward\"\n      'Ctrl-Alt-U':       \"subpar_backward_up\"\n      'Ctrl-Alt-D':       \"subpar_forward_down\"\n      'Ctrl-Alt-P':       \"subpar_backward_down\"\n      'Ctrl-Alt-N':       \"subpar_forward_up\"\n\n      'Shift-Ctrl-[':     \"subpar_backward_barf\"\n      'Ctrl-Alt-Right':   \"subpar_backward_barf\"\n      'Ctrl-]':           \"subpar_backward_barf\"\n\n      'Shift-Ctrl-]':     \"subpar_forward_barf\"\n      'Ctrl-Left':        \"subpar_forward_barf\"\n\n      'Shift-Ctrl-9':     \"subpar_backward_slurp\"\n      'Ctrl-Alt-Left':    \"subpar_backward_slurp\"\n      'Ctrl-[':           \"subpar_backward_slurp\"\n\n      'Shift-Ctrl-0':     \"subpar_forward_slurp\"\n      'Ctrl-Right':       \"subpar_forward_slurp\"\n\n      'Alt-Up':           \"subpar_splice_delete_backward\"\n      'Alt-Down':         \"subpar_splice_delete_forward\"\n      'Alt-S':            \"subpar_splice\"\n      'Ctrl-Alt-/':       \"subpar_indent_selection\"\n    })\n\n  ## paredit keys that defer if not in lisp code\n  (ref lisp-modes {lispz: true clojure: true commonlisp: true scheme: true})\n  (ref is-lisp-mode (pull lisp-modes))\n  (ref subpar-command (pull subpar.core))\n  (ref subpart (lambda [cmd opt]\n    (return (lambda [cm]\n      (ref mode (cm.getModeAt (cm.getCursor)))\n      (cond (is-lisp-mode mode.name)  ((subpar-command cmd) cm opt)\n            (else)                    CodeMirror.Pass\n      )\n    ))\n  ))\n  (ref code-mirror-commands (state.morph CodeMirror.commands))\n  (code-mirror-commands.update! {\n    ## paredit keys that defer if not in lisp code\n    subpar_backward_delete:        (subpart \"backward_delete\")\n    subpar_forward_delete:         (subpart \"forward_delete\")\n    subpar_forward_delete:         (subpart \"forward_delete\")\n\n    subpar_open_bracket:           (subpart \"open_expression\" \"()\")\n    subpar_open_square_bracket:    (subpart \"open_expression\" \"[]\")\n    subpar_open_braces:            (subpart \"open_expression\" \"{}\")\n\n    subpar_close_bracket:          (subpart \"close_expression\" \")\")\n    subpar_close_square_bracket:   (subpart \"close_expression\" \"]\")\n    subpar_close_braces:           (subpart \"close_expression\" \"}\")\n\n    subpar_double_quote:           (subpart \"double_quote\")\n\n    subpar_forward:                (subpart \"forward\")\n    subpar_backward:               (subpart \"backward\")\n    subpar_backward_up:            (subpart \"backward_up\")\n    subpar_forward_down:           (subpart \"forward_down\")\n    subpar_backward_down:          (subpart \"backward_down\")\n    subpar_forward_up:             (subpart \"forward_up\")\n\n    subpar_backward_barf:          (subpart \"backward_barf\")\n    subpar_backward_barf:          (subpart \"backward_barf\")\n    subpar_backward_barf:          (subpart \"backward_barf\")\n\n    subpar_forward_barf:           (subpart \"forward_barf\")\n    subpar_forward_barf:           (subpart \"forward_barf\")\n\n    subpar_backward_slurp:         (subpart \"backward_slurp\")\n    subpar_backward_slurp:         (subpart \"backward_slurp\")\n    subpar_backward_slurp:         (subpart \"backward_slurp\")\n\n    subpar_forward_slurp:          (subpart \"forward_slurp\")\n    subpar_forward_slurp:          (subpart \"forward_slurp\")\n\n    subpar_splice_delete_backward: (subpart \"splice_delete_backward\")\n    subpar_splice_delete_forward:  (subpart \"splice_delete_forward\")\n    subpar_splice:                 (subpart \"splice\")\n    subpar_indent_selection:       (subpart \"indent_selection\")\n  })\n"

lispz_modules['presentations/message2-demo']="(using [message]\n  (message.clear '/my-message-address/')\n  (message.trace false)\n\n  (ref @click       (dom.click \"my-message-address\" document.body))\n  (ref @mouse       (message.map @click \"mouse\" (lambda [event]\n                      {x: event.clientX  y: event.clientY}\n                    )))\n  (ref @top-left    (message.filter @mouse \"top-left\" (lambda [pos]\n                      (< pos.x pos.y)\n                    )))\n  (message.listen   @top-left (=> (console.log @.x @.y)))\n\n  ## Same again using compose\n  (cascade\n    (=> (dom.click \"my-message-address\" document.body))\n    (=> (message.map      @	\"mouse\" 	(=> {x: @.clientX  y: @.clientY})))\n    (=> (message.filter	  @	\"top-left\"  (=> (< @.x @.y))))\n    (=> (message.throttle @ 2000))\n    (=> (message.listen   @ (=> (console.log @.x @.y))))\n  )\n)\n"

lispz_modules['projects']="(using [github dexie]\n  ### spec: Projects\n    Empiric can work on one project at a time. A project is a reflection of\n    a Github project - warts and all. A best effort is made to keep the local\n    copy and that on Github in sync.\n  ###\n  (ref db (new Dexie \"Empiric-Projects\"))\n  ((db.version 1).stores {\n    projects: \"&name\"\n    files: \"++,project,path\"\n  })\n  (db.open)\n\n  ### spec: Projects >> Open a Project\n    Once a project has been added to the system on this browser, it can be\n    opened by name. Returned is an object with the cached project meta-data\n    and a reference for accessing the GitHub repository.\n      (describe \"Open a project that does not exist\" (lambda []\n        (ref project (projects.open \"I don't exist\"))\n      ))\n      (describe \"Open an existing project\" (lambda []\n        (ref project (projects.open \"Empiric\"))\n      ))\n  ###\n  (ref open (lambda [name]\n    (return (when (db.projects.get name) [data]\n      (ref repo (github.repo data.username data.password data.project-name))\n      (return {meta-data: data repo})\n    ))\n  ))\n\n  ### spec: Projects >> Add or Update a Project\n    It is possible to change some of the meta-data associated with a project.\n    Most specifically this includes the necessaries to contact the GitHub\n    source of truth for this project.\n  ###\n  (ref add (lambda [name username password project-name]\n    (ref project (db.projects.get name))\n    (ref update! (lambda [data]\n      (ref data (stateful.morph data))\n      (data.update! username password project-name)\n      (return (db.projects.put data))\n    ))\n    (when  project [data] (update! data))\n    (promise.failed project [err] (update! {name}))\n  ))\n\n  ### spec: Projects >> List Known Projects\n    Return a promise that when fulfilled will provide an array of project\n    meta-data. It returns a promise.\n\n        (describe \"List Projects\" (lambda []\n          (it \"will return a list of known projects\" (lambda []\n            (when (projects.list) [list] (lambda []\n              ((expect list.length).toBeGreaterThan 0)\n            ))\n          ))\n        ))\n  ###\n  (ref list (lambda [] (return (db.projects.toArray))))\n\n  (export open)\n)\n"

lispz_modules['promise']="(ref reject-promise (lambda [message data type]\n  (ref name (or type \"Promise-Error\"))\n  (ref error (stateful.morph! (new Error message)))\n  (error.update! { name data })\n  (#join '' 'throw ' error)\n))\n(global reject-promise reject-promise)\n(global throw reject-promise)\n\n(global promise {})\n(global promise.rejected reject-promise)\n\n(macro promise [?params *body] (lambda ?params\n  (new Promise (lambda [resolve-promise catch-promise] *body))\n))\n\n(macro promise.callback [?params *body] (promise ?params\n  (ref callback (lambda [err result]\n    (cond err    (catch-promise  err)\n          (else) (resolve-promise result)\n    )\n  ))\n  (catch-errors (do *body) (catch-promise error))\n))\n(global promise.resolved (promise [pact] (resolve-promise pact)))\n\n(ref promised (lambda [pledge]\n  (ref is-function (=> (and (instance-of Function @) (is @.length 1))))\n  (cond (not pledge)              (promise.resolved pledge)\n        pledge.then               pledge\n        (is-function pledge)      (promised (pledge))\n        (else)                    (promise.resolved pledge)\n  )\n))\n(global promised promised)\n\n(macro when [pledge ?params *body]\n  (ref #last-promise#\n    ((promised pledge).then (lambda ?params *body))\n  )\n)\n\n(macro when-rejected [?params *body]\n  (#last-promise#.catch (lambda ?params *body))\n)\n\n(macro promise.failed [pledge ?errors *body]\n  ((promised pledge).catch (lambda ?errors *body))\n)\n\n(using [list]\n  ### Promises >> promise.all\n    Given a list of promises and constant data, will return a list of\n    returned data when all the promises have been resolved.\n  ###\n  (global promise.all (=>\n    (ref flattened (list.flatten (*arguments 0)))\n    (ref promisified (flattened.map (=> (promised @))))\n    (return (Promise.all promisified))\n  ))\n)\n\n(export [])\n"

lispz_modules['regex']="\n### spec: regex >> Extracting a substring\nA common problem is finding part of a string given a pattern.\n\n    (regex.substring href '/(.*)\\/[^\\/]*$/') ## retrieve base part of url\n###\n(ref substring (lambda [str re]\n  (ref match (str.match re))\n  (cond match  (second match) (else) \" \")\n))\n\n(export {substring})\n"

lispz_modules['riot']="### spec: Libraries >> RIOT\nA React-like, user interface library\n\nhttp://riotjs.com/\nhttps://github.com/riot/riot\n###\n(using  [jquery net dict dom counters list]\n  ## we need to update the tags cache\n  (stateful.morph! lispz.tags)\n  ### spec: RIOT >> Get Tag Definition by Name\n  ###\n  (ref tag-by-name (pull lispz.tags))\n\n  ## has side-effects as riot caches compile results\n  (ref compile (=> (riot.compile.apply riot arguments)))\n\n  (ref processed-tags (stateful {}))\n  (ref processed-tag  (pull processed-tags))\n\n  (ref child-tags (lambda [html-object]\n    (ref html (or html-object.html html-object))\n    (ref raw-tags (html.match '/<[^>\\s]+[^>]*?class=[\\'\\\"]?riot[\\s\\'\\\">]/g'))\n    (ref children ((or raw-tags [[]]).map (=> (last ('/^<(\\S*)/'.exec @)))))\n    (Object.keys (dict.set children))\n  ))\n  (ref tag-splitting-regex '/<([^\\/\\s]+)>((?:.|\\n)*)<\\/\\1>/g')\n  (ref split-tags (lambda [html]\n    (ref find-one (lambda\n      (cond (ref match (tag-splitting-regex.exec html)) (do\n        (ref result [[{ name: (second match) html: (first match) }]])\n        (result.concat (find-one))\n      ))\n    ))\n    (find-one)\n  ))\n\n  ### spec: RIOT >> load\n    Returns true if tag has been previously loaded. This\n    allows the caller to decided whether to reuse or\n    reinstate.\n  ###\n  (ref load (promise [name uri]\n    (ref usings (lambda [tags]\n      (ref new-tags (tags.filter (=>\n        (cond @.length (do\n          (ref processed (processed-tag @))\n          (processed-tags.update! @ true)\n          (not processed)\n        ) (else) false)\n      )))\n      (ref loaded (promise.all (new-tags.map (=>\n        (return (load @))\n      ))))\n      (when loaded (resolve-promise))\n    ))\n\n    (ref compile-and-process (lambda [tag-html]\n      ## remove comments so ic case it has tags inside\n      (ref no-comments (tag-html.replace '/<!--.*?-->/' \"\"))\n      ## since one riot file can have multiple tags, we must split...\n      (ref tags ((split-tags no-comments).filter (=> (not @))))\n      ## ... and process separately (for source-map clarity)\n      (tags.forEach (lambda [tag]\n        ## full qualify tag name with file if they don't match\n        (ref tag-name (cond\n          (is name tag.name)  name\n          (else)              (+ name \":\" tag.name)\n        ))\n        ## tell script and css tags where they come from, then compile\n        (ref add-options (+ \"$& options={\\\"url\\\":\\\"\" tag-name \"\\\"}\"))\n        (compile (tag.html.replace '/<(script|css)[^>]*/' add-options))\n      ))\n      ## lastly, look for riot tags inside that need loading (class=riot)\n      (usings (list.flatten (tags.map child-tags)))\n    ))\n\n    (ref retrieve-and-compile (lambda\n      (ref url\n        (or uri (+ (name.toLowerCase) \".riot.html\"))\n      )\n      (when (net.http-get url) [tag-html]\n        (lispz.tags.update! name tag-html)\n        (compile-and-process tag-html)\n      )\n    ))\n\n    (ref tag-def (tag-by-name name))\n    (cond\n      tag-def   (compile-and-process tag-def)\n      (else)    (retrieve-and-compile)\n    )\n  ))\n\n  (ref build (lambda [target-repo] (using [code-builder]\n    (return (code-builder target-repo \"riot\" [[\n      {repo: \"riot/riot\" files: [[\n        {include: '/^riot\\+compiler.js$/'}\n      ]]}\n    ]]))\n  )))\n  ### spec: RIOT >> mount\n  ###\n  (ref mount (=> (riot.mount.apply riot arguments)))\n\n  ### spec: RIOT >> inject\n    Load a named tag if needed, inject an instance into the DOM then mount it.\n    The name can be the name of the file followed by the specific element.\n  ###\n  (ref inject (promise [name-path attributes parent-selector]\n    (ref parts (name-path.split \"/\"))\n    (ref name  (last parts))\n    (ref file (first parts))\n    (ref exists (tag-by-name name))\n    (when (load name (+ file \".riot.html\"))\n      (cond exists (do\n        (ref tags (riot.mount name))\n        (resolve-promise (first tags))\n      ) (else) (do\n        (ref element (dom.element name attributes))\n        (ref parent (or parent-selector \"body\"))\n        (dom.append! parent element)\n        (ref tags (riot.mount element name))\n        (resolve-promise (first tags))\n      ))\n    )\n  ))\n\n  ### spec: riot >> Trigger Display Changes\n  ###\n  (ref update! (lambda [tag changes]\n    (tag.update! changes)\n    (tag.update) ## repaint\n  ))\n  (macro riot-tag [*body]\n    (ref tag (stateful.morph! this))\n    *body\n  )\n  ## modules must be on mount or mounting will happen before trigger is set\n  (macro mount-tag-using [modules *body]\n    (tag.on \"mount\" (=> (using modules *body)))\n  )\n\n  (ref loaded (net.script \"ext/riot.js\" (lambda (return window.riot))))\n  (promise.failed loaded (export {build}))\n  (when loaded (using [compilers]\n    (stateful.morph! riot.parsers.js)\n    (riot.parsers.js.update! {lispz:\n      (lambda [source options url]\n        (ref opts (or options url {}))\n        (ref name (+ (or url opts.url \"tags\") \".riot\"))\n        (compilers.lispz.compile source name)\n      )\n    })\n    (ref riot-elements (slice (document.getElementsByClassName \"riot\")))\n    (ref load-all (promise.all (riot-elements.map (lambda [element]\n      (ref name (element.tagName.toLowerCase))\n      (return (load name (element.getAttribute \"uri\")))\n    ))))\n    (when load-all\n      (riot.mount \"*\")\n      (export {build compile load mount inject update! child-tags tag-by-name})\n    )\n  ))\n)\n"

lispz_modules['sortable']="### spec: Libraries >> Sortable\nSortable   is a minimalist JavaScript library for reorderable drag-and-drop lists on modern browsers and touch devices. No jQuery. Supports Meteor, AngularJS, React, Polymer and any CSS library, e.g. Bootstrap\n\nhttps://github.com/RubaXa/Sortable\n###\n(using [net cdnjs dict]\n\n  (ref sortable-defaults {\n    dataIdAttr: name\n    store: {\n      get: (lambda [sortable]\n        (ref items (localStorage.getItem sortable.options.group))\n        (return ((or items \"\").split \"|\"))\n      )\n      set: (lambda [sortable]\n        (localStorage.setItem sortable.options.group ((sortable.toArray).join \"|\"))\n      )\n    }\n  })\n  ### spec: DOM >> Sortable Components\n  ###\n  (ref create (lambda [container name options]\n    (return (Sortable.create container\n      (dict.merge  sortable-defaults {group: (or name (Math.random))} options)\n    ))\n  ))\n\n  (ref build (lambda [target-repo]\n    (return (cdnjs.build target-repo \"sortable\" [[\n      {repo: \"sortable\" files: [[{include '/Sortable.js/'}]]}\n    ]]))\n  ))\n  (ref loaded (net.script \"ext/sortable.js\" (lambda [] (return window.Sortable))))\n  (when  loaded [] (export {build create}))\n  (promise.failed loaded [] (export {build}))\n)\n"

lispz_modules['source-map']="### spec: Libraries >> source-map\nhttps://github.com/mozilla/source-map\n###\n  (ref build (lambda [target-repo]\n    (using [code-builder]\n      (return (code-builder target-repo \"source-map\" [[\n        {repo: \"mozilla/source-map\" files: [[\n          {base: \"dist\" include: '/source-map.js$/'}\n        ]]}\n      ]]))\n    )\n  ))\n\n  ## loaded by lispz.js as it is needed early on\n  (=> (export { build }))\n"

lispz_modules['stateful']="### spec: basic >> state -- Stateful Containers\n  State is the elephant in the room - particularly in the functional programming paradigm.\n  When you have state that can be changed from outside, then any function that reads from it\n  no longer has referential integrity. This means that identical calls may not return identical\n  results.\n\n  But we need state. Without it the system is fully enclosed without input or output.\n  A referentially integrous :) function can be replaced by it's return value,\n  so why ever run it?\n\n  The aim is to be like any machine with the internals always working the same.\n  Think of a clock. The input is someone setting the time.\n  After that the external gearing, etc is meant to work consistently so that the\n  time advances at the correct pace. The current time is state. You can build and\n  test the entire device without the state. It is on the very outside. Once the\n  mechanism is working as expected, add a clock face and hands. Changing the hands\n  is input and displaying the time output. The latter can be considered a\n  side-effect.\n\n  The state container for lispz relies on polite access, not enforced rules. By custom an\n  function that changes ends in an exclamation mark. Use this to highlight review.\n  The default builder return an empty JavaScript dictionary.\n\n      (describe \"Create a new stateful object -- (ref context (stateful seed))\" (lambda []\n        (ref options (stateful {name: \"undefined\" address: \"nowhere\"}))\n        (it \"is able to read members directly -- context.member\" (lambda []\n          ((expect options.name).toBeEqual \"undefined\")\n        ))\n        (it \"is able to read members by key -- context[key]\" (lambda []\n          ((expect options[\"name\"]).toBeEqual \"undefined\")\n        ))\n        (it (+ \"is able to update a dictionary with changes -- \"\n          \"(context.update! {a: dictionary})\") (lambda []\n            (options.update! {name: \"Barney Rubble\" address: \"Next Door\"})\n            ((expect options.name).toBeEqual \"Barney Rubble\")\n            ((expect options.address).toBeEqual \"Next Door\")\n        )\n          )\n      ))\n\n  Javascript lives in the world of objects as well as functions. Sometimes to work in this world\n  objects need to be labelled as stateful. Use this approach as sparingly as possible. Always\n  consider other alternatives first.\n\n      (describe \"Creating a stateful reference -- (ref context (stateful.morph! this))\" (lambda []\n        (ref that {a: 1 b: 2})\n        (ref context (stateful.morph! that))\n        (it \"looks the same as the original object\" (lambda []\n          ((expect context.a).toBeEqual that.a)\n        ))\n        (it \"reflects changes to the original object\" (lambda []\n          (context.update! {a: 99})\n          ((expect that.a).toBeEqual 99)\n        ))\n      ))\n\n  Be polite and use this container responsibly. Adding protection adds overhead.\n  If you want to cheat, then on your head be it.\n###\n\n(macro #set! [list index value] (#join '' list '[' index ']=' value ';'))\n\n(ref #merge! (lambda [target source]\n  (ref keys (Object.keys source))\n  (ref own-keys (keys.filter (=> (source.hasOwnProperty @))))\n  (own-keys.forEach (lambda [key]\n    (ref source-child (get source key))\n    (ref target-child (get target key))\n    (ref is-dictionary (and\n      source-child target-child\n      (is source-child.constructor Object)\n      (is target-child.constructor Object)\n    ))\n    (cond is-dictionary\n      (#merge! target-child source-child)\n    (else) ## either does not exist or in super\n      (#set! target key source-child)\n    )\n  ))\n))\n\n(ref #morph! (lambda [obj]\n  (cond\n    obj.update!               obj ## already morphed\n    (instance-of Array obj)   (#morph-array!  obj)\n    (instance-of Object obj)  (#morph-object! obj)\n    (else)                    (#morph-object! { data: obj })\n  )\n))\n(ref #morph-object! (lambda [obj]\n  (Object.defineProperties obj {\n\n    update!: {value: (lambda [update value]\n      (ref target this)\n      (cond (is arguments.length 1)\n        (#merge! target update)\n      (and (target.hasOwnProperty update) (instance-of Object value))\n        (#merge! (get target update) value)\n      (else)\n        (#set! target update value)\n      )\n      target\n    )}\n\n    delete!: { value: (lambda [to-delete] (delete (get this to-delete))) }\n  })\n  obj\n))\n\n(ref #morph-array! (lambda [array]\n  (Object.defineProperties array {\n    update!:  { value: (lambda [index value] (#set! this index value)) }\n    push!:    { value: (=> (Array.prototype.push.apply this (*arguments 0))) }\n    pop!:     { value: (=> (Array.prototype.pop.apply this)) }\n  })\n  array\n))\n\n(global stateful (lambda [seed]\n  (ref item (cond\n    (instance-of Array seed)    (#morph-array!  (seed.slice))\n    (instance-of Object seed)   ((#morph-object! {}).update! seed)\n    (else)                      (#morph-object! (or seed {}))\n  ))\n))\n\n(global stateful.cache (curry [store update key]\n  (or (get store key) (do (store.update! key (update)) (get store key)))\n))\n\n(global stateful.morph! #morph!)\n\n### We sometimes need to change Lispz functionality ###\n(stateful.morph! lispz)\n\n(export [])\n"

lispz_modules['storage']="(using [dexie]\n  (export {})\n)\n"

lispz_modules['underscore']="### spec: Libraries >> Underscore\nJavaScript's utility _ belt\n\nhttp://underscorejs.org\nhttps://github.com/jashkenas/underscore\n###\n(using [net github]\n  (ref build (lambda [target-repo]\n    (ref sources [[{repo: \"jashkenas/underscore\" files:\n      [[{include: '/underscore.js$/'}]]}]])\n    (return (build target-repo \"underscore\" sources))\n  ))\n  (ref loaded (net.script \"ext/underscore.js\" (lambda (return window._))))\n  (when loaded (export { build }))\n)\n"

lispz_modules['utf8']="### spec: Libraries >> Utf8\nA robust UTF-8 encoder/decoder in JavaScript.\n\nhttps://git.io/utf8js\nhttps://github.com/mathiasbynens/utf8.js\n###\n  (ref build (lambda [target-repo] (using  [net github]\n    (return (code-builder target-repo \"utf8\" [[\n      {repo: \"utf8/utf8\" files: [[\n        {base: \"\" include: '/utf8.js$/'}\n      ]]}\n    ]]))\n  )))\n\n  (lispz.script \"ext/utf8.js\" (lambda (export { build })))\n"

lispz_modules['while']="### spec: basics >> Iteration\n\nIn the functional way of programming, loop style iteration is (almost) never needed.\nBecause of the 'almost' and to provide for those week on functional will,\nlispz provides one loop operator. It takes a test and a body.\n\n    (while (not (result)) (look-again))\n\nIn this case both are functions. Lispz furthers the functional cause by making\nassignment difficult and ugly.\n\nOf course the need for iteration remains no matter what programming discipline you follow.\nIn the functional world it is filled by ... you guessed it ... functions.\nFor arrays, JavaScript provides an excellent set documented in [List Processing](list-processing.md).\n###\n## Javascript does not (yet) have tail recursion - it is scheduled for 2016\n(macro while [test *body] (#join '' 'while(' test '){' *body '}'))\n"
var lispz = function() {
  if (!window.lispz_modules) window.lispz_modules = {}
  var logger = window.console.log,
  log = function() { logger.apply(console, arguments) }, references = [{}],
  delims = "(){}[],n".split(''), // characters that are not space separated atoms
  not_delims = delims.join("\\"), delims = delims.join('|\\'),
  stringRE =
    "''|'[\\s\\S]*?[^\\\\]':?|" +
    '""|"(?:.|\\r*\\n)*?[^\\\\]"|' +
    '###+(?:.|\\r*\\n)*?###+|' + '##\\s+.*?\\r*\\n|',
  tkre = new RegExp('(' + stringRE + '\\' + delims + "|[^\\s" + not_delims + "]+)", 'g'),
  opens = new Set("({["), closes = new Set(")}]"), ast_to_js,
  location = {line:1, name:"boot"}, globals = {}, load_index = 0,
  synonyms = {and:'&&', or:'||', is:'===', isnt:'!==', "=>": "lambda"},
  javascript = "",
  slice = function(list, from, to) {
    var line = list.line
    var sliced = [].slice.call(list, from, to)
    sliced.line = line
    return sliced
  },
  jsify = function(atom) {
    var js = ""
    if (/^'\/(?:.|\n)*'$/.test(atom)) {
      js = atom.slice(1, -1).replace(/\n/g, '\\n')
    } else if (/^'.*'$/.test(atom)) {
      js = atom.slice(1, -1).replace(/\\n/g, '\n')
    } else if (/^"(?:.|\r*\n)*"$/.test(atom)) {
      js = atom.replace(/\r*\n/g, '\\n')
    } else if (atom[0] == "-") {
      js = atom // unary minus or negative number
    } else {
      js = atom.replace(/\W/g, function(c) {
        var t = "$hpalcewqgutkri"["!#%&+:;<=>?@\\^~".indexOf(c)];
        return t ? ("_"+t+"_") : (c === "-") ? "_" : c
      })
    }
    return js
  },
  call_to_js = function(func, params) {
    params = slice(arguments, 1)
    if (synonyms[func]) func = synonyms[func]
    if (macros[func]) return macros[func].apply(lispz, params)
    func = ast_to_js(func)
    if (params[0] && params[0][0] === '.') func += ast_to_js(params.shift())
    if (params.length === 1 && params[0] === "arguments") {
      var parts = func.split(".")
      if (parts.length < 2 || /[\(\[\{]/.test(func)){
        params = ".apply(this,arguments)"
      } else {
        var context = parts.slice(0, -1).join(".")
        params = ".apply(" + context + ",arguments)"
      }
    } else {
      params = "(" + map_ast_to_js(params, ',').replace(/,\s*\./, ".") + ")"
    }
    if (func.startsWith("function(){")) func = "(" + func + ")"
    return "(_res_=" + func + params + ")"
  },
  function_to_js = function(params, body) {
    // functions can be created without a parameter list
    if (params instanceof Array && params[0] == "[") {
      body = slice(arguments, 1)
    } else {
      body = slice(arguments, 0)
      params = ["[", "_t_"]  // @ is the sole parameter
    }
    is_array = function(body) {
      return body[body.length-1] instanceof Array
    }
    is_attr = function(body) {
      return body[body.length-1][0] == "."
    }
    is_func = function(body) {
      return body.length > 1 && body[body.length-2] === "("
    }
    function_body_to_js = function() {
      if (body.length === 0) return ""
      var full_body = (body.length === 1 && body[0] instanceof Array) ? body[0] : body
      if (!is_array(full_body) && !is_attr(full_body) && !is_func(full_body)) {
        var end = full_body.length - 1
        full_body[end] = ["(","ref","_res_",full_body[end]]
      }
      body = map_ast_to_js(body, ";\n") + "\n;return _res_"
    }

    var header = "_res_=function("+params.slice(1).map(jsify).join(",")+")"
    var vars = vars_to_js(function_body_to_js)
    return header + "{\n"+vars+"\n"+body+"\n}\n"
  },
  vars_to_js = function(map_to_js) {
    var reference = {}
    references.push(reference)
    try {
      map_to_js()
      var vars = Object.keys(reference)
      if (!reference._res_) vars.push("_res_")
      return "var "+vars.join(",")+";"
    } finally { references.pop() }
  },
  add_reference = function(ast) {
    references[references.length - 1][jsify(ast)] = true
    return []
  },
  add_return = function(ast) {
    if (!ast.length) return ast
    if (ast[0] instanceof Array || ast[0] === "list" || ast[0] === "") {
      var end = ast.length - 1
      ast[end] = add_return(ast[end])
    } else if (ast[0] === "(") {
      if (ast[1] !== "return") {
        ast = ["(", "return", ast]
      }
    } else if (! (ast instanceof Array)) {
      ast = ["(", "return", ast]
    } else {
      throw "no return set for " + JSON.stringify(ast)
    }
    return ast
  },
  return_to_js = function() {
    var js = map_ast_to_js(slice(arguments), '\n')
    if (!js.startsWith("return")) js = ";return " + js
    return js
  },
  macro_to_js = function(name, pnames, body) {
    if (pnames instanceof Array && pnames[0] == "[") {
      body = slice(arguments, 2)
      pnames = slice(pnames, 1)
    } else {
      body = slice(arguments, 1)
      pnames = ["_t_"]  // @ is the sole parameter
    }
    var pnames_set = new Set(pnames)
    macros[name] = function(pvalues) {
      pvalues = slice(arguments)
      var args = {}
      for (var n = 0, v = 0; n < pnames.length; n++, v++) {
        var pname = pnames[n]
        var pvalue = pvalues[v]
        // if (pname[0] === '?' && v === pvalues.length - 1) args[pname] = "", v-- // skip ?param
        if (pname[0] === '?' && pvalue[0] != "[") args[pname] = "", v-- // skip ?param
        else args[pname] =
          (pname[0] === '*') ? ["list"].concat(slice(pvalues, v)) :
          (pname[0] === '&') ? ["["].concat(slice(pvalues, v)) : pvalue
      }
      var expand = function(ast) {
        return (ast instanceof Array) ? ast.map(expand) : args[ast] ||
          (pnames_set.has(ast) ? "" : ast)
      }
      var js = ast_to_js(expand((body.length > 1) ? ["list"].concat(body) : body[0]))
      return js
    }
    return "/*macro "+name+"*/"
  },
  array_to_js = function() {
    var its = slice(arguments)
    if (arguments.length === 1 && arguments[0][0] === '[') {
      return "(_res_=[" + map_ast_to_js(its, ',') + "])"
    }
    return map_ast_to_js(its, ',')
  },
  list_to_js = function(its) {
    return (its && its.length) ? map_ast_to_js(slice(arguments), ';\n') : ""
  },
  // A dictionary can be a symbol table or k-value pair
  dict_to_js = function(kvp) {
    var dict = []; kvp = slice(arguments)
    for (var key, i = 0, l = kvp.length; i < l; i++) {
      if ((key = kvp[i])[kvp[i].length - 1] === ":") {
        dict.push("'"+jsify(key.slice(0, -1))+"':"+ast_to_js(kvp[++i]));
      } else {
        dict.push("'"+jsify(key)+"':"+ast_to_js(key));
      }
    }
    return "(_res_={" + dict.join(',') + "})";
  },
  join_to_js = function(sep, parts) {
    parts = slice((arguments.length > 2) ? arguments : parts, 1)
    return map_ast_to_js(parts, ast_to_js(sep))
  },
  run_ast = function(ast) {
    return ast.map(function(code) { return eval(ast_to_js(code)) })
  },
  immediate_to_js = function() {
    var lspz = run_ast(slice(arguments)).join("\n")
    var js = ast_to_js(parse_to_ast(lspz))
    return js
  },
  immediate_from_ast = function() {
    var js = ast_to_js(ast_to_ast.apply(this, arguments))
    return js
  },
  ast_to_ast = function(func, args) {
    args = slice(arguments, 1)
    var actor = lispz[func] ? lispz[func] : lispz.globals[func]
    if (! actor) throw { message: "No immediate function", name: func}
    var ast = actor.apply(lispz, args)
    return ast
  },
  // processing pairs of list elements
  pairs_to_js = function(pairs, tween, sep) {
    var el = [], tween = ast_to_js(tween);
    if (!(pairs.length % 2)) throw {message:"Unmatched pairs",pairs:pairs}
    for (var i = 1, l = pairs.length; i < l; i += 2) {
      var second = pairs[i + 1]
      el.push(ast_to_js(pairs[i]) + tween + ast_to_js(second))
    }
    return el.join(ast_to_js(sep))
  },
  binop_to_js = function(op) {
    macros[op] = function(list) {
      return '(_res_=' + map_ast_to_js(slice(arguments), op) + ')'
    }
  },
  parsers = [
    [/^(\(|\{|\[)$/, function(env) {
      env.stack.push(env.node)
      env.node = [env.atom]
      if (env.atom == "(" && env.line) {
        env.node.line = env.line
        env.line = 0
      }
    }],
    [/^(\)|\}|\])$/, function(env) {
      var f = env.node;
      (env.node = env.stack.pop()).push(f)
    }],
    /*
     * Record line number for JS comment. Can't add a new element,
     * so only do it if last compiled is not an atom.
     */
    [/^\n$/, function(env) {
      if (!env.node.length) return
      var atom = env.node[env.node.length - 1]
      if (!(atom instanceof Array)) return
      // atom.unshift('\n', location.name, location.line)
    }]
  ],
  empty_words = { "of": true, ",": true, "in": true },
  comment = function(atom) {
    return atom[0] === "#" && atom[1] === "#" && (atom[2] === '#' || atom[2] == ' ')
  },
  parse_to_ast = function(source) {
    var env = { ast: [], stack: [] }
    env.node = env.ast
    tkre.lastIndex = 0
    while ((env.atom = tkre.exec(source.toString())) && (env.atom = env.atom[1])) {
      lines_in_atom = (env.atom.match(/\n/g) || []).length
      location.line += lines_in_atom
      if (lines_in_atom) env.line = location.line
      var is_parser = function(parser) {
        if (!parser[0].test(env.atom)) return false
        parser[1](env)
        return true
      }
      if (!comment(env.atom) && !parsers.some(is_parser) && !empty_words[env.atom]) {
        env.node.push(env.atom);
      }
    }
    if (env.stack.length != 0) {
      throw "missing close brace"
    }
    return env.ast
  },
  ast_to_js = function(ast) {
    var js = (ast instanceof Array) ? macros[ast[0]] ?
      macros[ast[0]].apply(ast, slice(ast, 1)) : list_to_js(ast) : jsify(ast)
    if (ast.line) js = "/*##" + ast.line + "##*/" + js.trimLeft()
    return js
  },
  map_ast_to_js = function(ast, joiner) {
    return ast.map(ast_to_js).filter(function(item){return item.length}).join(joiner)
  },
  base64 = function(content) {
    return btoa(content.replace(/[^\0-\xFF]/, " "))
  },
  data_uri = function(base64_content) {
    return "data:application/json;charset=utf-8;base64," + base64_content
  },
  append_source_map = function(js, name, source) {
    var lines = js.split("\n")
    var source_map = new sourceMap.SourceMapGenerator({file: name})
    source_map.setSourceContent(name, source)
    lines.forEach(function(line, line_number) {
      var re = /(.*?)\/\*##(\d+)##\*\//g, match, column = 0
      while (match = re.exec(line)) {
        column += match.index + match[0].length
        source_map.addMapping({
          source:    name,
          // generated line + 1 for base 1, 2 for function definition
          generated: { line: line_number + 2,  column: column },
          original:  { line: +match[2],        column: 0 }
        })
      }
    })
    var url = data_uri(base64(source_map.toString()))
    return js + "\n//# sourceMappingURL=" + url + "\n//# sourceURL=" + name + ".js\n"
  }
  compile = function(source, name) {
    var last_module = location
    location = { name:name || "", line:1 }
    var ast = parse_to_ast(source)
    location = last_module

    var body, vars = vars_to_js(function(){ body = ast.map(ast_to_js) })
    body.unshift(vars)
    return append_source_map(body.join(";\n"), name + ".lispz", source)
  },
  //######################### Script Loader ####################################//
  cache = {}, manifest = [], pending_module = {},
  http_request = function(uri, type, callback, headers, body) {
    var req = new XMLHttpRequest()
    req.open(type, uri, true)
    if (lispz.debug_mode && uri.indexOf(":") == -1)
      req.setRequestHeader("Cache-Control", "no-cache")
    for (var key in (headers || {})) req.setRequestHeader(key, headers[key])
    req.onerror = function(err) {
      callback(JSON.stringify({ uri: uri, error: err }, null, 2))
    }
    req.onload = function() {
      manifest.push(req.responseURL)
      if (req.status >= 200 && req.status <= 299) {
        callback(null, req.responseText)
      } else {
        req.onerror({ status: req.statusText, response: req.responseText })
      }
    }
    req.send(body)
  },
  module_init = function(uri) {
    var js = compile(lispz_modules[uri], uri)
    init_func = eval('(function(__module_ready__){\n' + js + '\n})')
    init_func(function(exports) {
      cache[uri.split('/').pop()] = cache[uri] = exports
      var on_readies = pending_module[uri]
      delete pending_module[uri]
      on_readies.forEach(function(call_module) {call_module(exports)})
    })
  },
  load_one = function(uri, on_ready) {
    if (cache[uri]) return on_ready()
    if (pending_module[uri]) return pending_module[uri].push(on_ready)
    pending_module[uri] = [on_ready]; var js = ""
    if (lispz_modules[uri]) return module_init(uri)
    http_request(uri + ".lispz", 'GET', function(err, response_text) {
      if (err) throw err
      var name = uri.split('/').pop()
      lispz_modules[uri] = response_text
      module_init(uri)
    })
  },
  reload = function(uris) {
    uris.split(",").forEach(function(uri) {
      delete pending_module[uri]; delete cache[uri]; delete lispz_modules[uri]
    })
  },
  // Special to set variables loaded with requires
  requires_to_js = function(list) {
    list = list.slice(list.indexOf("[") + 1)
    return 'var ' + list.map(function(module) {
      var name = module.trim().split('/').pop()
      return jsify(name) + '=lispz.cache["' + name + '"]'
    }) + ';'
  },
  load = function(uris, on_all_ready) {
    uris = uris.split(",")
    var next_uri = function() {
      if (uris.length) load_one(uris.shift().trim(), next_uri)
      else if (on_all_ready) on_all_ready()
    }
    next_uri()
  },
  set_debug_mode = function(debugging) {
    lispz.debug_mode = debugging
  },
  //##################    where to get scripts    #############################//
  lispz_url = document.querySelector('script[src*="lispz.js"]').getAttribute('src'),
  lispz_base_path = /^(.*?)(?:ext\/)?lispz.js/.exec(lispz_url)[1] || "./",
  css = function(uri) {
    el = document.createElement("link")
    el.setAttribute("type", "text/css")
    el.setAttribute("rel", "stylesheet")
    el.setAttribute("href",  lispz_base_path+uri)
    document.head.appendChild(el)
  },
  script = function(uri, when_loaded) {
    if (cache[uri]) return when_loaded()
    cache[uri] = true
    el = document.createElement("script")
    document.head.appendChild(el)
    el.addEventListener("load",  function(evt) { setTimeout(when_loaded, 20) })
    el.addEventListener("error", function(evt) { console.log(evt); when_loaded(evt) })
    el.setAttribute("src", lispz_base_path+uri)
  }
  window.addEventListener("error", window.onerror)
  other_window_onload = window.onload
  window.onload = function() {
    window.onload = null
    if (other_window_onload) other_window_onload()
    var q = lispz_url.split('#')
    script("ext/source-map.js", function() {
    load(((q.length == 1) ? "core" : "core," + q.pop()),
      function() {
        var to_load = [], to_run = []
        slice(document.querySelectorAll('script[type="text/lispz"]')).forEach(
          function (script) {
            var src = script.getAttribute("src")
            if (src) {
              var parts = src.split(".")
              if (parts.pop() == "lispz") src = parts.join(".")
              to_load.push(src)
            } else {
              to_run.push(script)
            }
          })
        var end_run = function() {
          if (to_run.length) {
            to_run.forEach(function(script) {
              run("script", script.textContent)
            })
          }
          if (window.onload) window.onload() // someome else set it
        }
        if (to_load.length) load(to_load.join(","), end_run)
        else                end_run()
    })})
  }
  //#########################    Helpers    ####################################//
  var clone = function (obj) {
    var target = {};
    for (var i in obj) if (obj.hasOwnProperty(i)) target[i] = obj[i];
    return target;
  }
  //#########################   Interface   ####################################//
  var macros = {
    '(': call_to_js, '[': array_to_js, '{': dict_to_js, 'macro': macro_to_js,
    '#join': join_to_js, '#pairs': pairs_to_js, '#binop': binop_to_js,
    '#requires': requires_to_js, 'list': list_to_js, "#ast": immediate_from_ast,
    'immediate': immediate_to_js, 'lambda': function_to_js,
    "return": return_to_js
  }
  // add all standard binary operations (+, -, etc)
  "+,-,*,/,&&,||,==,===,<=,>=,!=,!==,<,>,^,%,|,&,^".split(',').forEach(binop_to_js)

  return { compile: compile, parsers: parsers, load: load,
           macros: macros, cache: cache, http_request: http_request,
           clone: clone, manifest: manifest, script: script, css: css,
           synonyms: synonyms, globals: globals, tags: {}, slice: slice,
           location: location, path_base: lispz_base_path,
           set_debug_mode: set_debug_mode, log: log, empty_words: empty_words,
           add_reference: add_reference, reload: reload, base64, data_uri
          }
}()


/*bootstrap*/

lispz.tags['bootstrap']="<panel>\n  <!-- ### spec: bootstrap >> Panels\n\n    A panel is a UI component that provides decorations around your content.\n    The header includes a title and a menu button.\n    An optional footer can include more text.\n\n        <panel [context=default|primary|success|info|warning|danger]\n                  [heading=heading-text] [footer=footer-text]\n                  [menu=menu-id] height=[nn%,nn]>\n          panel-body-content-html\n        </panel>\n\n    The context defines the colours use for the decoration.\n    The _menu-id_ is used to listen on a messaging channel that\n    can publish menu contents.\n\n        <panel [context=default|primary|success|info|warning|danger]\n                [heading=heading-text] [footer=footer-text]\n                [menu=menu-id] height=[nn%,nn]>\n         panel-body-content-html\n         </panel>\n    ### -->\n  <div class=\"panel { context }\" name=outer>\n    <div class=panel-heading if={ opts.heading } name=heading\n         ><bars-menu align=right name={ opts.menu } owner={ opts.owner }/>\n         <yield from=buttons/>\n         <h3 class=panel-title>{ opts.heading }</h3></div>\n    <div class=\"panel-body\" name=body><yield from=body/></div>\n    <div class=panel-footer if={ opts.footer } name=footer\n         >{ opts.footer }</div>\n  </div>\n\n  <style>\n    panel .panel {\n      position: relative;\n    }\n    panel .panel-title {\n      cursor: default;\n    }\n    panel buttons .btn-toolbar {\n      margin-top: -2px;\n    }\n    panel .panel-body {\n      position: absolute;\n      top: 40px;\n      bottom: 2px;\n      left: 0;\n      right: 2px;\n      overflow: auto;\n    }\n    panel > .panel {\n      margin-top: 10px;\n      margin-bottom: 10px;\n    }\n  </style>\n\n  <script type=text/lispz>\n    (riot-tag\n      (tag.update! {context: (+ \"panel-\" (or opts.context \"default\"))})\n      (mount-tag-using [dom]\n        (cond opts.height (do\n          (ref px (cond\n            (is \"%\" (opts.height.slice -1))\n              (/ (* window.innerHeight (opts.height.slice 0 -1)) 100)\n            (else)\n              opts.height\n          ))\n          (dom.style! tag.outer {height: (+ px \"px\")})\n        ))\n      )\n    )\n  </script>\n</panel>\n\n<panels>\n  <yield/>\n  <style>\n    /* show the move cursor as the user moves the mouse over the panel header.*/\n    panels .panel-title { cursor: move; }\n    panels .draggable { display: block; }\n  </style>\n  <script type=text/lispz>\n    (riot-tag (mount-tag-using [sortable]\n      (sortable.create tag.root (or opts.name \"sortable\") {\n        draggable:  \".draggable\"\n        handle:     \".panel-title\"\n        dataIdAttr: \"name\"\n      })\n    ))\n  </script>\n</panels>\n\n<modal>\n  <!-- ### spec: bootstrap >> Modals\n\n  Modals pop up and deny access to the rest of the page until they are dismissed.\n\n      <modal name=n [title=heading-text] [buttons=a,*b]\n        [context=default|primary|success|info|warning|danger]>\n          modal-body-content-html\n      </modal>\n\n  Buttons are added to a footer, with the one starting with a star being the default.\n  When a modal button is pressed it will send a message with a topic of\n  _modal-name/button-name/button_.\n\n      <modal name=login-dialog title=\"...\" buttons=\"Log in,Cancel\">...</modal>\n      ....\n      (message.listen \"login-dialog/Log in/button\" (lambda ...)\n  ### -->\n  <div class=\"modal fade\" role=\"dialog\" aria-labelledby={ opts.name }\n  name=modal style=\"display:none;\">\n    <div class=\"modal-dialog { modal-lg: opts.size=='large' }\n    { modal-sm: opts.size=='small' }\" role=\"document\">\n      <div class=\"modal-content\">\n        <div class=\"modal-header\" if={ opts.title }>\n          <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">\n            <span aria-hidden=\"true\">&times;</span>\n          </button>\n          <h4 class=\"modal-title\" id={ opts.name }>{ opts.title }</h4>\n        </div>\n        <div class=\"modal-body\"><yield/></div>\n        <div class=\"modal-footer\">\n          <push-button each={ buttons }\n          type={ type } name={ name }>\n            { title }\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n  <style>\n  </style>\n  <script type=text/lispz>\n    (riot-tag (using [dom]\n      (cond opts.buttons (do\n        (ref buttons (stateful []))\n        (tag.update! {buttons: buttons})\n        ((opts.buttons.split \",\").forEach (lambda [title]\n          (buttons.push! (cond\n            (ref primary (is \"*\" (first title))) (do\n              (ref fixed-title (title.slice 1))\n              (ref name\n                (+ \"modal/\" opts.name \"/\" fixed-title)\n              )\n              {name title: fixed-title type: \"primary\"}\n            ) (else) (do\n              (ref name (+ \"modal/\" opts.name \"/\" title))\n              {name title type: \"default\"}\n            )\n          ))\n        ))\n      ))\n      (mount-tag-using [bootstrap message]\n        (ref modal-tag ($ tag.modal))\n        (ref show (=> (modal-tag.modal \"show\")))\n        (ref hide (=> (modal-tag.modal \"hide\")))\n        (message.dispatch\n          (+ \"modal/\" opts.name) { show hide }\n        )\n        (ref transfer-event (=>\n          (ref address (+ \"modal/\" opts.name \"/\" @))\n          (modal-tag.on (+ @ \".bs.modal\") (=>\n            (message.send address { element: tag.root })\n          ))\n        ))\n        (transfer-event \"hidden\")\n        (transfer-event \"shown\")\n      )\n    ))\n  </script>\n</modal>\n\n<buttons>\n  <!-- ### spec: bootstrap >> Buttons >> Button Bar\n  A simplistic component to group buttons into a tool-bar.\n  ### -->\n  <div class=\"btn-toolbar { right: opts.align === 'right' }\" role=\"toolbar\">\n    <yield/>\n  </div>\n  <style>\n    buttons > div.right { float: right; margin-right: 1em }\n  </style>\n  <script type=text/lispz> </script>\n</buttons>\n\n<button-group>\n  <!-- ### spec: bootstrap >> Buttons >> Button Groups\n  Buttons in a group are pushed together without separating space.\n  It is a good visual effect for radio buttons.\n  ### -->\n  <div class=\"btn-group\" role=\"group\"> <yield/> </div>\n  <style> </style>\n  <script type=text/lispz> </script>\n</button-group>\n\n<push-button>\n  <!-- ### spec: bootstrap >> Buttons >> Push Button\n  Standard button representation - a button you push to take an action.\n\n  When a button is pressed it will send a message with a topic of\n  _button-name/on_ and _button-name/off_.\n\n  Attributes are\n\n  * **name**: Name of button - used to send the push messages\n  * **type**: [*default|primary|success|info|warning|danger]\n  * **size**: [*default|lg|sm|xs]\n  ### -->\n  <button class=\n    \"btn btn-{ opts.type || 'default' } btn-{ opts.size || 'default' }\"\n    name=button>\n    <yield/>\n  </button>\n  <style></style>\n  <script type=text/lispz>\n    (riot-tag (mount-tag-using [message]\n      (tag.button.addEventListener \"click\" (=>\n        (message.send opts.name {})\n      ))\n    ))\n  </script>\n</push-button>\n\n<bars-menu>\n  <!-- ### spec: bootstrap >> Menus\n\n  A menu is a multi-level option selection.\n  Both menu contents and results selected communicate by messages.\n\n  Menu contents loading can be driven by the menu component or an external provider.\n  For the former, the menu component sends out a message when a user asks to open the menu.\n  It is up to a listener to provide the data requested.\n  Use this if the menu contents change between uses.\n\n        (message.listen \"specifications-menu/open\" (lambda\n          (ref menu (dict.map lispz_modules (lambda [title source]\n            (return {topic: \"specifications\" title source})\n          )))\n          (message.send \"specifications-menu\" (menu.sort))\n        ))\n\n  This example has a flat single-level list. All menus send a message when\n  displayed with the name of the menu concatenated to _.open_.\n  They also listen on the menu name as an address,\n  so you can pass the resulting menu back.\n\n  If an external controller knows when the menu changes,\n  or if the menu is static, then send the contents to a named message address\n  so that the specified menu can be reloaded. If this happens before the menu\n  is displayed the menu will not be loaded.\n  To fix this, wait for the menu to be ready.\n\n        (when (message.ready> \"specifications-menu\")\n          (message.send \"specifications-menu\" nenu)\n        )\n  The menu itself is a dictionary with the format:\n\n       (ref test-menu\n          [[\n            { header: true title: \"Heading 1\" }\n            { title: \"Item 1\" topic: \"Test menu item 1\" }\n            { title: \"Item 2\" children: [[{ title: \"Item 2a\" }]] }\n            { divider: true }\n            { title: \"item 2\" disabled: true }\n          ]]\n        )\n      (message.send \"test-menu\" test-menu)\n\n  where _header_ and _divider_ are list separates that cannot be selected.\n  For the rest, _title_ is the text displayed, _topic_ is part of the the address\n  for the message sent, _children_ defines sub-menus and _disabled_ is for items\n  that cannot be selected.\n\n  If a menu item has a topic entry, a message will be sent to that an address\n  made up of the component owner, dash, topic.\n\n      (message.listen \"Test Panel 2 - Test menu item 1\" (lambda [data] (debug data)))\n\n  ###\n  ### spec: bootstrap >> Menus >> bars-menu\n\n  This menu type displays three horizontal bars - sometime call a _hamburger_.\n  Click it opens up a drop-down menu.\n\n      <bars-menu align=left|center|right name=name owner=owning-component />\n\n  The owner is prepended to the response to a menu selection so that the correct\n  component can respond.\n  ### -->\n  <div name=dropdown class=\"dropdown { right: opts.align === 'right' }\">\n    <a style=\"text-decoration: none\" data-toggle=\"dropdown\" name=bars\n    class=\"glyphicon glyphicon-menu-hamburger dropdown-toggle\" aria-hidden=\"true\"\n    ></a>\n    <ul class=\"dropdown-menu { dropdown-menu-right: opts.align === 'right' }\">\n      <li each={ items } class={ dropdown-header: header && title,\n          divider: divider, disabled: disabled }><a onclick={ goto } href=\"#\">\n          <span class=\"pointer right float-right\" if={ children }></span>\n          { title }&nbsp;&nbsp;&nbsp;\n      </a></li>\n    </ul>\n  </div>\n  <style>\n    bars-menu > div.right { float: right }\n    bars-menu span.caret { margin-left: -11px }\n    bars-menu a.dropdown-toggle { cursor: pointer }\n  </style>\n  <script type=text/lispz>\n    (riot-tag (mount-tag-using [message riot]\n      (message.listen opts.name (lambda [items]\n        (riot.update! tag {items root: (or items [[]])})\n      ))\n      (($ tag.dropdown).on \"show.bs.dropdown\" (lambda\n        (message.send (+ opts.name \"/open\"))\n        (riot.update! tag {items: tag.root})\n      ))\n      (tag.update! {goto: (lambda [ev]\n        (cond ev.item.topic (message.send\n          (+ opts.owner \"/\" ev.item.topic)\n          {item: ev.item owner: opts.owner action: \"select\"}))\n        (cond ev.item.children (do\n          (tag.update! {items: ev.item.children})\n          (ev.currentTarget.blur)\n          (ev.stopPropagation)\n        ))\n      )})\n    ))\n  </script>\n</bars-menu>\n\n<tree>\n  <!-- ### spec: bootstrap >> Trees\n    A tree provides an identical interface to a menu.\n    Visually all levels to the current selection remain displayed.\n    Selecting a branch will toggle it opened or closed.\n    Selecting a leaf will send a message to the owning component.\n  ### -->\n  <tree-component name=base/>\n  <script type=text/lispz>\n    (riot-tag (using [message riot]\n      (message.listen opts.name (lambda [items]\n        (riot.update! tag {children: {base: {children: items}}})\n        (tag.update) ## once more for luck\n      ))\n    ))\n  </script>\n</tree>\n\n<tree-component>\n  <ul class=\"dropdown-menu\">\n    <li each={ item, i in items }\n        class={ dropdown-header: item.header && item.title,\n        divider: item.divider, disabled: item.disabled }\n        ><a onclick={ parent.goto } href=\"#\">\n        <span if={ item.children }\n              class=\"glyphicon glyphicon-triangle-right\"\n              aria-hidden=\"true\"></span>{ item.title }</a>\n        <tree-component if={ item.children } name={ item.title }>\n    </li>\n  </ul>\n  <style>\n    tree-component ul {\n      display: inherit !important;\n      position: inherit !important;\n    }\n    tree-component:not([name=base]) > ul {\n      display: none !important;\n    }\n    tree-component:not([name=base]).open > ul {\n      margin-left:  9px;\n      margin-right: 9px;\n      display: inherit !important;\n    }\n    tree-component span.glyphicon {\n      margin-left: -18px;\n    }\n  </style>\n  <script type=text/lispz>\n    (riot-tag (using [message dict]\n      (tag.on \"update\" (lambda [data]\n        (cond (and opts.name tag.parent.children) (do\n          (tag.update! {items: (get tag.parent.children opts.name \"children\")})\n          ## convert children into a dictionary if necessary\n          (tag.update! {children: (cond\n            (instance-of Array tag.items) (dict.from-list tag.items \"title\")\n            tag.items                     tag.items\n          )})\n        ))\n      ))\n\n      (tag.update! {goto: (lambda [ev]\n        (ref item ev.item.item)\n        (ref topic (or item.topic item.title ))\n        (cond topic (message.send topic {item action: \"select\"}))\n        (cond item.children (do\n          (ref tree ev.currentTarget.nextElementSibling)\n          (tree.classList.toggle \"open\")\n          (tree.parentElement.classList.toggle \"bg-info\")\n        ))\n        (ev.stopPropagation)\n      )})\n    ))\n  </script>\n</tree-component>\n\n<sidebar>\n  <!-- ### spec: bootstrap >> Side-bars\n    A side-bar is a slide-in draw. When hidden it displays a string\n    down the left side of the screen. Clicking on the 3-bars icon at\n    the top will slide the panel in and out.\n  ### -->\n  <a aria-hidden=\"true\" name=hamburger\n    class=\"glyphicon glyphicon-menu-hamburger\"></a>\n  <div id=sidebar class=\"container bg-primary\"><yield/></div>\n  <style>\n    sidebar > a {\n      text-decoration: none !important;\n      position: absolute !important;\n      z-index: 2000;\n    }\n    #sidebar {\n      z-index: 1000;\n      position: fixed;\n      width: 0;\n      height: 100%;\n      overflow-y: auto;\n      -webkit-transition: all 0.5s ease;\n      -moz-transition: all 0.5s ease;\n      -o-transition: all 0.5s ease;\n      transition: all 0.5s ease;\n      padding-right: 0;\n      overflow: hidden;\n    }\n    #sidebar.toggled { width: auto; padding-right: 15px; }\n  </style>\n  <script type=text/lispz>\n    (riot-tag (using [message dom]\n      (ref hamburger (stateful.morph! tag.hamburger))\n      (hamburger.update! {onclick: (lambda\n        (tag.sidebar.classList.toggle \"toggled\")\n        (delay 300 ## must be after slide action\n          (message.send \"dom/page-content-wrapper-padding\" tag.sidebar.offsetWidth)\n        )\n      )})\n      (mount-tag-using [riot] (delay 300\n        (message.send \"dom/page-content-wrapper-padding\" tag.sidebar.offsetWidth)\n      ))\n    ))\n  </script>\n</sidebar>\n\n<page-content>\n  <div id=page_content_wrapper>\n    <div class={ container-fluid: opts.fluid, container: !opts.fluid }>\n      <yield/>\n    </div>\n  </div>\n  <style>\n    #page_content_wrapper {\n      width: 100%;\n      position: absolute;\n    }\n  </style>\n  <script type=text/lispz>\n    (riot-tag (using [message dom]\n      (message.listen \"dom/page-content-wrapper-padding\" (lambda [px]\n        (dom.style! tag.page-content-wrapper {paddingLeft: (+ px \"px\")})\n      ))\n    ))\n  </script>\n</page-content>\n\n<bootstrap>\n  <div id=page-wrapper><yield/></div>\n  <style>\n    .pointer {\n      border: 5px solid transparent;\n      display: inline-block;\n      width: 0;\n      height: 0;\n      vertical-align: middle;\n    }\n    .pointer.float-right {\n      float: right;\n      margin-top: 5px;\n    }\n    .pointer.up {\n        border-bottom: 5px solid;\n    }\n    .pointer.right {\n        border-left: 5px solid;\n    }\n    .pointer.down {\n        border-top: 5px solid;\n    }\n    .pointer.left {\n        border-right: 5px solid;\n    }\n  </style>\n  <script type=text/lispz>\n    (riot-tag (using [dom net jquery riot message bootstrap]\n      (dom.append! \"head\" (dom.element \"meta\"\n        {name: \"viewport\" content: \"width=device-width, initial-scale=1\"}\n      ))\n    ))\n  </script>\n</bootstrap>\n"


/*code-editor*/

lispz.tags['code-editor']="<code-editor>\n  <panel height={ opts.height } heading={ heading }\n      menu={ menu } owner={ _riot_id }>\n      <yield to=buttons><yield from=buttons></yield></yield>\n  </panel>\n  <style>\n    code-editor .CodeMirror {\n      position: absolute;\n      top: 0; bottom: 0;\n      left: 5px; right: 0;\n      height: initial;\n    }\n  </style>\n  <script type=text/lispz>\n    (riot-tag\n      (tag.update! {menu: \"codemirror/menu\" heading: (or opts.heading \"Edit\")})\n      (mount-tag-using [codemirror message message dict events]\n        (ref filename-key (+ \"code-editor/\" opts.name \"/filename\"))\n        (ref cm (codemirror.open tag._riot_id tag.tags.panel.body))\n\n        (ref open (lambda [packet]\n          (codemirror.set-mode cm packet.key)\n          (cond (isnt (get packet.key 0) \".\") (do\n            (tag.update! {heading: (last (packet.key.split \"/\"))})\n            (tag.update)\n          ))\n          (localStorage.setItem filename-key packet.key)\n          (cm.setValue packet.contents)\n        ))\n\n        (ref contents-key (+ \"code-editor/\" opts.name \"/contents\"))\n        (ref filename (localStorage.getItem filename-key))\n        (cond filename (delay 100\n          (open {key: filename contents: (localStorage.getItem contents-key)})\n        ))\n        (cm.on \"change\" (events.delay 1000 (lambda\n          (ref contents (cm.getValue)) (ref name opts.name)\n          (localStorage.setItem contents-key contents)\n          (message.send (+ \"code-editor/\" name \"/change\") { contents name })\n        )))\n\n        (ref append (lambda [packet]\n          (cm.replaceRange packet.contents (CodeMirror.Pos (cm.lastLine)))\n        ))\n\n        (ref contents (=> (cm.getValue)))\n\n        (ref focus (=> (cm.focus)))\n\n        (message.dispatch (+ \"code-editor/\" opts.name)\n          { open append contents focus }\n        )\n      )\n    )\n  </script>\n</code-editor>\n"


/*firepad*/

lispz.tags['firepad']="<firepad>\n  <!-- <firepad name=pad-name [db=default]> -->\n  <panel height={ opts.height } heading={ heading }\n      menu={ menu } owner={ _riot_id }>\n    <div name=wrapper class=wrapper></div>\n  </panel>\n  <style>\n    firepad .wrapper {\n      position: absolute;\n      top: 0; bottom: 0;\n      left: 0; right: 0;\n      height: initial;\n    }\n    firepad .CodeMirror {\n      position: absolute;\n      top: 0; bottom: 0;\n      left: 5px; right: 0;\n      height: initial;\n    }\n    a.powered-by-firepad { display: none; }\n    div.firepad-toolbar { margin-top: -25px; }\n  </style>\n  <script type=text/lispz>\n    (riot-tag\n      (tag.update! {menu: \"codemirror/menu\"})\n      (tag.update! {heading: \"Edit\"})\n      (mount-tag-using [firebase codemirror firepad message dict]\n        (ref filename-key (+ \"codemirror/\" opts.name \"/filename\"))\n        (ref cm (codemirror.open tag._riot_id tag.tags.panel.wrapper))\n        (tag.update! {pad: (stateful {\n          setText:  (lambda [contents] (cm.setValue contents))\n          on-ready: (lambda [act] (act))\n        })})\n\n        (ref open (lambda [packet]\n          (codemirror.set-mode cm packet.key)\n          (tag.update! {heading: (last (packet.key.split \"/\"))})\n          (localStorage.setItem filename-key packet.key)\n          (cond packet.contents (tag.pad.setText packet.contents))\n          (tag.update)\n        ))\n\n        (cond\n          opts.db (do\n            (ref db (firebase.attach (+ \"firepads/\" opts.name) opts.db))\n            (tag.update! {pad: (stateful.morph (Firepad.fromCodeMirror db cm\n              {richTextShortcuts: false richTextToolbar: false}\n            ))})\n            (tag.pad.update! {on-ready: (lambda [act] (tag.pad.on \"ready\" act))})\n          ) (else) (do ## without firebase we need to persist locally\n            (ref contents-key (+ \"codemirror/\" opts.name \"/contents\"))\n            (ref filename (localStorage.getItem filename-key))\n            (cond filename (delay 100\n              (open {key:      filename\n                     contents: (localStorage.getItem contents-key)})\n            ))\n            (cm.on \"change\" (lambda\n              (localStorage.setItem contents-key (cm.getValue))\n            ))\n          )\n        )\n\n        (tag.pad.on-ready (lambda\n          (message.dispatch (+ \"firepad/\" opts.name) { open })\n        ))\n      )\n    )\n  </script>\n</firepad>\n"


/*github*/

lispz.tags['github']="<github>\n</github>\n\n<github-login>\n  <modal name=github-login size=\"small\" title=\"GitHub Login\" buttons=\"*Sign In\">\n    <div style=\"position:absolute;top:20px;left:16px;\">\n      <svg xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:cc=\"http://creativecommons.org/ns#\" xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"2 2 81 79\" height=\"83px\" width=\"83px\" xml:space=\"preserve\" id=\"svg2\" version=\"1.1\"  preserveAspectRatio=\"xMidYMid meet\"><rect id=\"svgEditorBackground\" x=\"0\" y=\"0\" width=\"83\" height=\"83\" style=\"fill: none; stroke: none;\"/><metadata id=\"metadata8\"><rdf:RDF><cc:Work rdf:about=\"\"><dc:format>image/svg+xml</dc:format><dc:type rdf:resource=\"http://purl.org/dc/dcmitype/StillImage\"/></cc:Work></rdf:RDF></metadata><defs id=\"defs6\"><clipPath id=\"clipPath20\" clipPathUnits=\"userSpaceOnUse\"><path id=\"path18\" d=\"M 0,4999.88 V 0 h 5309.73 v 4999.88 z\"/></clipPath></defs><g transform=\"matrix(1.3333333,0,0,-1.3333333,0,666.65333)\" id=\"g10\"><g transform=\"scale(0.1)\" id=\"g12\"><g id=\"g14\"><g clip-path=\"url(#clipPath20)\" id=\"g16\"><path id=\"path24\" style=\"fill:#1b1817;fill-opacity:1;fill-rule:evenodd;stroke:none\" d=\"M217.5955922475381,4947.035689638439c-89.94000000000005,0,-162.8800000000001,-72.93000000000029,-162.8800000000001,-162.89999999999964c0,-71.96000000000004,46.67000000000007,-133.02000000000044,111.40000000000009,-154.5699999999997c8.150000000000091,-1.4899999999997817,11.11999999999989,3.5399999999999636,11.11999999999989,7.8599999999996735c0,3.8699999999998913,-0.14000000000010004,14.109999999999673,-0.2200000000000273,27.699999999999818c-45.309999999999945,-9.840000000000146,-54.86999999999989,21.840000000000146,-54.86999999999989,21.840000000000146c-7.410000000000082,18.81999999999971,-18.089999999999918,23.829999999999927,-18.089999999999918,23.829999999999927c-14.789999999999964,10.100000000000364,1.1199999999998909,9.899999999999636,1.1199999999998909,9.899999999999636c16.34999999999991,-1.1499999999996362,24.950000000000045,-16.789999999999964,24.950000000000045,-16.789999999999964c14.529999999999973,-24.890000000000327,38.13000000000011,-17.699999999999818,47.41000000000008,-13.529999999999745c1.4800000000000182,10.520000000000437,5.6900000000000555,17.699999999999818,10.339999999999918,21.770000000000437c-36.17000000000007,4.119999999999891,-74.20000000000005,18.090000000000146,-74.20000000000005,80.51000000000022c0,17.789999999999964,6.349999999999909,32.31999999999971,16.769999999999982,43.710000000000036c-1.6800000000000637,4.119999999999891,-7.269999999999982,20.68000000000029,1.599999999999909,43.10999999999967c0,0,13.670000000000073,4.380000000000109,44.789999999999964,-16.6899999999996c12.990000000000009,3.6099999999996726,26.930000000000064,5.4099999999998545,40.77999999999997,5.479999999999563c13.839999999999918,-0.06999999999970895,27.769999999999982,-1.869999999999891,40.77999999999997,-5.479999999999563c31.09999999999991,21.06999999999971,44.75,16.6899999999996,44.75,16.6899999999996c8.8900000000001,-22.43000000000029,3.2999999999999545,-38.98999999999978,1.6300000000001091,-43.10999999999967c10.440000000000055,-11.390000000000327,16.74000000000001,-25.920000000000073,16.74000000000001,-43.710000000000036c0,-62.57999999999993,-38.08999999999992,-76.35000000000036,-74.37000000000012,-80.38000000000011c5.839999999999918,-5.029999999999745,11.049999999999955,-14.970000000000255,11.049999999999955,-30.170000000000073c0,-21.770000000000437,-0.20000000000004547,-39.340000000000146,-0.20000000000004547,-44.68000000000029c0,-4.3599999999996735,2.9400000000000546,-9.430000000000291,11.200000000000045,-7.8400000000001455c64.68000000000006,21.590000000000146,111.30999999999995,82.60000000000036,111.30999999999995,154.55000000000018c0,89.97000000000025,-72.94000000000005,162.89999999999964,-162.91000000000008,162.89999999999964\" transform=\"matrix(1.82417 0 0 1.82417 -77.5862 -4045.5)\"/><path id=\"path42\" style=\"fill:none;stroke:#3a7fc3;stroke-width:10;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:10;stroke-dasharray:none;stroke-opacity:1\" d=\"m 2248.98,4994.88 v -5\"/></g></g></g></g></svg>\n    </div>\n    <form class=form-horizontal style=\"margin-left:100px\">\n      <input type=hidden name=login value=false class=login>\n      <input type=text class=form-control name=username placeholder=\"User Name\">\n      <br>\n      <input type=password class=form-control name=password placeholder=Password>\n      <br>\n      <input type=checkbox name=remember\n        data-toggle=tooltip\n        title=\"Only use on a secure, private account\"> Remember me\n    </form>\n  </modal>\n  <style>\n  </style>\n  <script type=text/lispz>\n    (riot-tag (mount-tag-using [github message dom]\n      (ref login-element (first\n        (tag.root.getElementsByClassName \"login\")\n      ))\n      (message.listen \"modal/githib-login/shown\" (=>\n        (login-element.setAttribute \"value\" \"false\")\n      ))\n      (message.listen \"modal/github-login/Sign In\" (=>\n        (login-element.setAttribute \"value\" \"true\")\n        (message.send \"modal/github-login/hide\")\n      ))\n    ))\n  </script>\n</github-login>\n"


/*iframe-panel*/

lispz.tags['iframe-panel']="<iframe-panel>\n  <panel height={ opts.height } heading={ heading } menu={ menu } owner={ _riot_id }>\n    <yield to=body><iframe name=iframe class=iframe></iframe></yield>\n  </panel>\n  <style>\n    iframe-panel .panel-body {\n      bottom: 0;\n      left: 1px;\n      right: 1px;\n      padding: 0;\n      padding-bottom: 1px;\n    }\n    iframe-panel .iframe {\n      position: absolute;\n      height: 100%;\n      width: 100%;\n    }\n  </style>\n  <script type=text/lispz>\n    (riot-tag\n      (tag.update! {menu: opts.menu heading: opts.heading})\n      (mount-tag-using [message]\n        (ref iframe tag.tags.panel.iframe)\n        (ref iframe-doc (or iframe.contentDocument iframe.contentWindow.document))\n\n        (cond opts.src (iframe.setAttribute \"src\" opts.src))\n\n        (tag.update! {\n          open: (lambda [packet]\n            (tag.update! {heading: (or packet.heading tag.heading)})\n            (cond packet.menu (tag.update! {menu: packet.menu}))\n            (iframe-doc.open)\n            (iframe-doc.write (+\n              \"<!DOCTYPE html><html><head><meta charset='utf-8'>\"\n              (or packet.head \"\")\"</head><body>\" (or packet.body \"\") \"</body></html>\"\n            ))\n            (iframe-doc.close)\n            (tag.update)\n          )\n        })\n      )\n    )\n  </script>\n</iframe-panel>\n"


/*lispz*/

lispz.tags['lispz']="<lispz>\n  <bootstrap class=riot>\n    <page-content fluid=true>\n      <panels name=editor-panels>\n        <code-editor class=\"riot col-sm-6 draggable\" name=code\n          height=46% heading=Lispz>\n          <yield to=buttons><buttons name=code/buttons align=right>\n            <push-button name=code/run type=info size=xs title=\"<alt><enter>\">Run</push-button>\n          </buttons></yield>\n        </code-editor>\n        <code-editor  class=\"riot col-sm-6 draggable\" name=compiled\n          height=46% heading=\"Generated Javascript\" />\n        <code-editor  class=\"riot col-sm-6 draggable\" name=output\n          height=46% heading=\"Console\" />\n        <markdown class=\"riot col-sm-6 draggable\" name=manual\n          href=\"README.md\"\n          height=46% heading=\"Manual\" />\n      </panels>\n    </page-content>\n  </bootstrap>\n\n  <script type=\"text/lispz\">\n    (riot-tag (using [message]\n      (lispz.set-debug-mode true)\n\n      (ref open (lambda [topic key contents]\n        (message.send (+ \"code-editor/\" topic \"/open\") {key contents})\n      ))\n\n      (when (message.ready> \"code-editor/code/open\")\n        (open \"code\" \".lispz\" \"\")\n        (message.send \"code-editor/code/focus\" {})\n      )\n\n      (ref clear_result_panels (=>\n        (open \"output\" \".txt\" \"\") (open \"compiled\" \".js\" \"\")\n      ))\n      (message.listen \"code-editor/run/prepare\" clear_result_panels)\n\n      (ref log (lambda [output]\n        (message.send \"code-editor/output/append\" {\n          key:      \".text\"\n          contents: (+ output \"\\n\")\n        })\n      ))\n\n      (using [js_beautify compilers]\n        (ref compiler (get compilers \"lispz\"))\n        (message.listen \"code-editor/run/compiled\" (lambda [compiled]\n          (open \"compiled\" \".js\" (js_beautify compiled.js))\n        ))\n        (ref compile-and-show (lambda [source]\n          (clear_result_panels)\n          (ref compiled (compiler.compile source \"Scratchpad\"))\n          (ref beaut-js (js_beautify compiled))\n          (open \"compiled\" \".js\" beaut-js)\n          compiled\n        ))\n        (message.listen \"code-editor/code/change\" (=>\n          (compile-and-show @.contents))\n        )\n        (message.listen \"code/run\" (=>\n          (ref sources> (message.request> \"code-editor/code/contents\" @))\n          (when sources> [sources]\n            (compilers.run [[(compile-and-show (first sources))]])\n          )\n        ))\n      )\n\n      (stateful.morph! console)\n      (console.update! {log: (=> (log (+ ((*arguments 0).join \" \"))) null)})\n      (message.listen \"code-editor/run/output\" (=> (log @.output)))\n    ))\n  </script>\n</lispz>\n"


/*markdown*/

lispz.tags['markdown']="<markdown>\n  <panel height={ opts.height } heading={ heading } menu={ menu } owner={ _riot_id }>\n    <div name=wrapper class=wrapper></div>\n  </panel>\n  <style>\n  </style>\n  <script type=text/lispz>\n    (riot-tag\n      (ref markdown-menu (+ \"panel/markdown/\" opts.name \"/menu\"))\n      (ref markdown-menu-action (+ markdown-menu \"/action\"))\n      (tag.update! {menu: markdown-menu heading: opts.heading})\n      (mount-tag-using [markdown dom net message dict]\n        (ref contents-area tag.tags.panel.body)\n\n        ## hamburger menu lists a history of pages followed\n        (ref history (stateful))\n        (ref address (+ tag._riot_id \"/\" markdown-menu-action))\n        (message.listen  address (lambda [packet]\n          ## load an item selected from the hamburger\n          (load packet.item.href)\n        ))\n        (ref open (lambda [md from]\n          (ref from (or from \"\"))\n          (dom.inner-html! contents-area (markdown.compile md))\n          ((dom.select contents-area \"a\").forEach (lambda [link]\n            (ref href (link.getAttribute \"href\"))\n            (cond (not (net.external? href)) (do\n              (link.addEventListener \"click\" (lambda [evt]\n                (load (+ from href))\n                (evt.preventDefault)\n              ))\n            ))\n          ))\n        ))\n        (ref load (lambda [href]\n          ## Update the hamburger with the latest history update\n          (history.update! href true)\n          (ref menu (dict.map history (lambda [href]\n            (ref title (first ((net.url-actor href).split \".\")))\n            (return {topic: markdown-menu-action href title})\n          )))\n          (message.send markdown-menu (menu.reverse))\n          ## then continue loading and displaying\n          (ref loaded (net.http-get href))\n          (when loaded [md] (open md (net.url-path href)))\n          (promise.failed loaded [err] (debug err))\n        ))\n        (cond opts.href (load opts.href))\n\n        ### spec: Markdown >> Panel\n          Showdown can take markdown text or url and display the\n          HTML created - including most Github extensions.\n\n          In the component HTML section, define a showdown panel as follows.\n          The href is optional, and the panel will start empty without it.\n\n              &lt;showdown name=manual heading=\"Manual\"\n                href=\"https://cdn.jsdelivr.net/gh/paulmarrington/lispz/README.md\"\n              /&gt;\n\n          To load a different markdown document from a server, send a message.\n          The final part of the address is the name attribute to the showdown\n          element above.\n\n              ((message.send \"showdown/manual/open\") {\n                href: \"another-url\"\n              })\n\n          Alternatively, pass the markdown directly in a string with the load\n          message.\n\n              ((message.send \"showdown/manual/load\") {\n                markdown: \"# Heading\\n*This is markdown*\"\n              })\n        ###\n        (message.dispatch (+ \"showdown/\" opts.name) { open load })\n      )\n    )\n  </script>\n</markdown>\n"
